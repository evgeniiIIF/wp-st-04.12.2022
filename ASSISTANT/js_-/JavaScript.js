_____________________________________________________________Движки___________________________________________________________________________

У браузера есть собственный движок, который иногда называют «виртуальная машина JavaScript».

Разные движки имеют разные «кодовые имена». Например:

V8 – в Chrome и Opera.
SpiderMonkey – в Firefox.
…Ещё есть «Trident» и «Chakra» для разных версий IE, «ChakraCore» для Microsoft Edge, «Nitro» и «SquirrelFish» для Safari и т.д.
_____________________________________________________________Добавление скрипта___________________________________________________________________________

Вышеприведённый пример можно разделить на два скрипта:

<script src="file.js"></script>
<script>
  alert(1);
</script>
Итого
Для добавления кода JavaScript на страницу используется тег <script>
Атрибуты type и language необязательны.
Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>.
_____________________________________________________________Структура кода___________________________________________________________________________

alert("Теперь всё в порядке");

[1, 2].forEach(alert)
---------------------коментарии--------------------------
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
---------------------------------
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
---------------------------------
Используйте горячие клавиши!
В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш Ctrl+/ для 
однострочного комментария и что-то вроде Ctrl+Shift+/ – для многострочных комментариев
(выделите кусок кода и нажмите комбинацию клавиш).
В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.


_________________________________________________Строгий режим — "use strict"_____________________________________________________________________
"use strict";

// этот код работает в современном режиме
...
----------------
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке

"use strict";

// строгий режим не активирован
Над "use strict" могут быть записаны только комментарии.

-------------------
'use strict'; <Shift+Enter для перехода на новую строку>
//  ...ваш код...
<Enter для запуска>
В большинстве браузеров, включая Chrome и Firefox, это работает.

В старых браузерах консоль не учитывает такой use strict, там можно «оборачивать» код в функцию, вот так:

(function() {
  'use strict';

  // ...ваш код...
})()
_____________________________________________________________Переменные___________________________________________________________________________

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, 
посетителей и других данных.

let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
-----------------
несколько переменных

let user = 'John';
let age = 25;
let message = 'Hello';
-------------------
Мы также можем изменить его столько раз, сколько захотим:

let message;

message = 'Hello!';

message = 'World!'; // значение изменено

alert(message);
-------------------
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!
------------------
Повторное объявление вызывает ошибку
Переменная может быть объявлена только один раз.

Повторное объявление той же переменной является ошибкой:

let message = "Это";

// повторение ключевого слова 'let' приводит к ошибке
let message = "Другое"; // SyntaxError: 'message' has already been declared
Поэтому следует объявлять переменную только один раз и затем использовать её уже без let.
-------------------
Имена переменных
В JavaScript есть два ограничения, касающиеся имён переменных:

Имя переменной должно содержать только буквы, цифры или символы $ и _.
Первый символ не должен быть цифрой.
Примеры допустимых имён:

let userName;
let test123;
Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое 
следующее слово начинается с заглавной буквы: myVeryLongName.

Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, 
как и буквы, без какого-либо особого значения.
Регистр имеет значение
Переменные с именами apple и AppLE – это две разные переменные.
--------------------
Зарезервированные имена
Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, 
потому что они используются самим языком.

Например: let, class, return и function зарезервированы.

Приведённый ниже код даёт синтаксическую ошибку:

let let = 5; // нельзя назвать переменную "let", ошибка!
let return = 5; // также нельзя назвать переменную "return", ошибка!
---------------------
Константы
Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

const myBirthday = '18.04.1982';
Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. 
Попытка сделать это приведёт к ошибке:

const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
Если программист уверен, что переменная никогда не будет меняться, он может гарантировать 
это и наглядно донести до каждого, объявив её через const.
--------------------
неизменяемые константы пишем в верхнем регистре
const COLOR_ORANGE = "#FF7F00";

изменяемые в нижнем
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
--------------------

_____________________________________________________________Типы данных___________________________________________________________________________

В JavaScript есть 8 основных типов.

number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
object для более сложных структур данных.
symbol для уникальных идентификаторов.

Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
_______________________________________Взаимодействие: alert, prompt, confirm__выпадаючие окна_______________________________________________________

Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

alert
показывает сообщение.
alert("Hello");
Hello
-------------
prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null,
если была нажата кнопка «Отмена» или Esc с клавиатуры.Функция prompt принимает два аргумента:

result = prompt(title, [default]);
Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

title
Текст для отображения в окне.
default
Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
Квадратные скобки в синтаксисе [...]
Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.

Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result.
Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.

Например:

let age = prompt('Сколько тебе лет?', 100);

alert(`Тебе ${age} лет!`); // Тебе 100 лет!
Для IE: всегда устанавливайте значение по умолчанию
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку "undefined" в поле для ввода.

Запустите код в Internet Explorer и посмотрите на результат:

let test = prompt("Test");
Чтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

let test = prompt("Test", ''); // <-- для IE
------------------
confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, 
если нажата кнопка «Отмена» или Esc с клавиатуры.
result = confirm(question);
Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

Результат – true, если нажата кнопка OK. В других случаях – false.

Например:

let isBoss = confirm("Ты здесь главный?");

alert( isBoss ); // true, если нажата OK
-----------------
Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной 
частью страницы до тех пор, пока окно не будет закрыто.

На все указанные методы распространяются два ограничения:

Расположение окон определяется браузером. Обычно окна находятся в центре.
Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия
с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.

______________________________________________________Преобразование типов___________________________________________________________

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.
Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). 
Для примитивных значений работает очевидным образом.

Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
Преобразование подчиняется правилам:

Значение	Становится…

undefined	NaN
null		0
true / false	1 / 0
string		Пробельные символы по краям обрезаются. 
Далее, если остаётся пустая строка, то получаем 0, 
иначе из непустой строки «считывается» число. При ошибке результат NaN.
---------------
Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
Подчиняется правилам:

Значение	Становится…
0, null, undefined, NaN, ""	false
любое другое значение	true
Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

undefined при численном преобразовании становится NaN, не 0.
"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.


____________________________________________________Базовые операторы, математика______________________________________________
https://learn.javascript.ru/operators

Сложение +,
Вычитание -,
Умножение *,
Деление /,
Взятие остатка от деления %,
Возведение в степень **.

alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)


Приоритет	Название	Обозначение
…	…	…
17		унарный плюс		+
17		унарный минус		-
16		возведение в степень	**
15		умножение		*
15		деление			/
13		сложение		+
13		вычитание		-
…	…	…
3		присваивание		=
…	…	…

Важно:
Инкремент/декремент можно применить только к переменной. 
Попытка использовать его на значении, типа 5++, приведёт к ошибке.

Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
«Префиксная форма» — это когда оператор идёт перед переменной: ++counter.

______________________________________________________Операторы сравнения__________________________________________________
https://learn.javascript.ru/comparison

Важно: Boolean(-1) // true

Сравнение разных типов
При сравнении значений разных типов JavaScript приводит каждое из них к числу.


alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' == 1 ); // true, строка '01' становится числом 1


alert( true == 1 ); // true
alert( false == 0 ); // true
------

Забавное следствие

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
------

Оператор строгого равенства === проверяет равенство без приведения типов.

alert( 0 === false ); // false, так как сравниваются разные типы
alert( 0 == false ); // true
alert( null === undefined ); // false
alert( null == undefined ); // true
-----

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
alert( null > -1 );  // true
alert( null < 1 );  // true

> <= - сравнения преобразуют null к 0 а == равенство нет!

С точки зрения математики это странно. Результат последнего сравнения говорит о том, что 
"null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, 
рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.

С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: 
эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.
---------

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
Почему же сравнение undefined с нулём всегда ложно?

На это есть следующие причины:

Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN,
 а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.
--------
Итого
Операторы сравнения возвращают значения логического типа.
Строки сравниваются посимвольно в лексикографическом порядке.
Значения разных типов при сравнении приводятся к числу. 
Исключением является сравнение с помощью операторов строгого равенства/неравенства.
Значения null и undefined равны == друг другу и не равны любому другому значению.
Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, 
которые могут принимать значения null/undefined.
Хорошей идеей будет сделать отдельную проверку на null/undefined.

_________________________________________________Условное ветвление: if, '?'__________________________________________________

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
-----------
Условный оператор „?“
let result = условие ? значение1 : значение2;
---
Несколько операторов „?“

let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );
---
_____________________________________________________Логические операторы____________________________________________________
Приоритет: высший у НЕ ! потом && потом || 
------
Важно: Boolean(-1) // true
------

|| (ИЛИ)
Существует всего четыре возможные логические комбинации:
"||" возвращает первое true или последнее false

alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
-------------------

&& (И)
возвращает первое false или последнее true

alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
-------------------

! (НЕ)


Сначала приводит аргумент к логическому типу true/false.
Затем возвращает противоположное значение.

alert( !true ); // false
alert( !0 ); // true

В частности, двойное НЕ используют для преобразования значений к логическому типу:
alert( !!"non-empty string" ); // true
alert( !!null ); // false

alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false

_______________________________________________Оператор объединения с null '??'_______________________________________________

оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
result = a ?? b

Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:
result = (a !== null && a !== undefined) ? a : b;
------------
Например, в следующем примере, если переменная user не определена, покажем модальное окно с надписью Аноним:

let user;
alert(user ?? "Аноним"); // Аноним

Конечно, если бы переменная user содержала любое значение, кроме null/undefined, то мы бы увидели его:

let user = "Иван";
alert(user ?? "Аноним"); // Иван
------------
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое определённое значение:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
-----------
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
----------
Приоритет

let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
---------
JavaScript запрещает использование оператора ?? вместе с && и ||, 
если только приоритет явно не указан в круглых скобках.

let x = (1 && 2) ?? 3; // Работает без ошибок
alert(x); // 2


_________________________________________________Циклы while и for______________________________________________

Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.

outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');

В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с именем outer, 
и управление перейдёт со строки, помеченной (*), к alert('Готово!').

Можно размещать метку на отдельной строке:
outer:
for (let i = 0; i < 3; i++) { ... }
Директива continue также может быть использована с меткой. 
В этом случае управление перейдёт на следующую итерацию цикла с меткой.

_________________________________________________Конструкция "switch"__________________________________________________

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}
Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.
----------------

let a = 2 + 2;

switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
Теперь оба варианта 3 и 5 выводят одно сообщение.
Тип имеет значение

_____________________________________________________Функции_____________________________________________________

https://learn.javascript.ru/function-basics
----------
У Function Expression ставится точка с запятой ; на конце, а в Function Declaration нет:

function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
-----------
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

В строгом режиме, когда Function Declaration находится в блоке {...}, 
функция доступна везде внутри блока. Но не снаружи него.
-----------
Функции-стрелки, основы

let sum = (a, b) => a + b;

alert( sum(1, 2) ); // 3
----
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет') :
  () => alert("Здравствуйте!");

welcome(); // теперь всё в порядке
----
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3
----

_________________________________________________Опциональная цепочка '?.'_______________________________________________
Проблема «несуществующего свойства»

let user = {}; // пользователь без свойства address
alert(user.address.street); // ошибка!
---
// Произойдёт ошибка, если querySelector(...) равен null.
let html = document.querySelector('.my-element').innerHTML;
------------------
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, 
если часть перед ?. имеет значение undefined или null.
Переменная перед ?. должна быть объявлена


let user = {}; // пользователь без адреса
alert( user?.address?.street ); // undefined (без ошибки)
------------------
Чтение адреса с помощью конструкции user?.address выполняется без ошибок, даже если объекта user не существует:

let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
------------------
 ?.() используется для вызова потенциально несуществующей функции.
В следующем примере не у всех пользователей есть метод admin:

let user1 = {
  admin() {
    alert("Я администратор");
  }
}

let user2 = {};

user1.admin?.(); // Я администратор
user2.admin?.();
------------------
?.[], если значение свойства требуется получить с помощью квадратных скобок [], а не через точку .. 

let user1 = {
  firstName: "Иван"
};

let user2 = null; // Представим, что пользователь не авторизован

let key = "firstName";

alert( user1?.[key] ); // Иван
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
------------------
delete user?.name; // Удалить user.name, если пользователь существует

------------------

_____________________________________________________________Обьекты___________________________________________________________
Проверить является ли обьектом

function isObject(obj){
    return Object.prototype.toString.call(obj) === '[object Object]';
}

Объекты для хранения именованных коллекций.

let user = {     // объект
  name: "John",  // под ключом "name" хранится значение "John"
  age: 30        // под ключом "age" хранится значение 30
};
_________________
если использовать число в качестве ключа, то оно превратится в строку "0":

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
_________________
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали
_________________

// получаем свойства объекта: получить значение свойства обьекта
alert( user.name ); // John
alert( user.age ); // 30
_________________
let key = prompt("Что вы хотите узнать о пользователе?", "name"); 
или let key = "name"

// доступ к свойству через переменную
alert( user[key] ); // John (если ввели "name")
_________________

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
alert(user["likes birds"]); // true

Значение может быть любого типа. Давайте добавить свойство в обьект с логическим значением:
user.isAdmin = true;
user["likes birds"] = true;

удалить свойство обьекта 
delete user.age;

Проверить существует ли ключь в обьекте (свойство с ключем)
"age" in object
========или============
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key

-----------------------
Цикл для обьектов «for…in»
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
for (key in object) {
  // тело цикла выполняется для каждого свойства объекта
}

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
-----------------------
Проверка обьекта на пустоту 'isEmptyObject'
Просто в цикле перебираем свойства объекта и возвращаем false, как только встречаем свойство./
function isEmpty(obj) {
  for (let key in obj) {
    // если тело цикла начнет выполняться - значит в объекте есть свойства
    return false;
  }
  return true;
}
или
!Object.keys(obj).length
-----------------------
Упорядочевание свойств
свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
https://learn.javascript.ru/object#uporyadochenie-svoystv-obekta
-----------------------
Клонирование и объединение объектов, Object.assign
При копировании переменной с объектом создаётся ещё одна ссылка на тот же самый объект.
дублировать объект Создать независимую копию, клон?

Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех 
перечисленных объектов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

et user = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }
Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:
___________________
Мы также можем использовать Object.assign для замены for..in на простое клонирование:

let user = {
  name: "Иван",
  age: 30
};

let clone = Object.assign({}, user);
Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.
_____________
Глубокое клонирование, используя рекурсию.
Или, чтобы не изобретать велосипед, использовать готовую 
реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
-----------------------
Для доступа к информации внутри объекта метод может использовать ключевое слово this.

Значение this – это объект «перед точкой», который использовался для вызова метода.

Например:

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
-----------------------
______________________________________________Конструкторы, создание объектов через new________________________________

Конструкторы, создание объектов через "new"
Функции-конструкторы являются обычными функциями. Но есть два соглашения:

Имя функции-конструктора должно начинаться с большой буквы.
Функция-конструктор должна вызываться при помощи оператора "new".

function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");

alert(user.name); // Вася
alert(user.isAdmin); // fals
_______________
ели есть return

function BigUser() {
  this.name = "Вася";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект

А вот пример с пустым return (или мы могли бы поставить примитив после return, неважно)
function SmallUser() {
  this.name = "Вася";
  return; // <-- возвращает this
}
alert( new SmallUser() );  // this
alert( new SmallUser().name );  // Вася
_______________
Создание методов в конструкторе
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}

let vasya = new User("Вася");

vasya.sayHi(); // Меня зовут: Вася

/*
vasya = {
   name: "Вася",
   sayHi: function() { ... }
}
*/
-----------------------
_____________________________________________________Символы___________________________________________________
«Символ» представляет собой уникальный идентификатор.
При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, 
это всё равно будут разные символы
---
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2);
---
Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться 
и перезаписать их из других частей программы.



// Создаём символ id с описанием (именем) "id"
let id = Symbol("id");

Если же мы действительно хотим вывести символ с помощью alert, 
то необходимо явно преобразовать его с помощью метода .toString(), вот так:

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

Или мы можем обратиться к свойству symbol.description, чтобы вывести только описание:

let id = Symbol("id");
alert(id.description); // id
_______________________
Мы хотим добавить к ним идентификаторы.
Используем для этого символьный ключ:

let user = {
  name: "Вася"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
_____________________
Символы в литеральном объекте
Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.

let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
___________
Символы игнорируются циклом for…in
А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
__________
Глобальные символы

Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. 
Но иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью. 

Например, разные части нашего приложения хотят получить доступ к символу "id", 
подразумевая именно одно и то же свойство.

Для этого существует глобальный реестр символов. 
Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно 
будет возвращаться один и тот же символ.

Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).

Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же 
создаётся новый символ Symbol(key) и записывается в реестр под ключом key.

Символы, содержащиеся в реестре, называются глобальными символами. Если вам нужен символ, 
доступный везде в коде – используйте глобальные символы.

Одинаковые символы
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true
_____________
// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
______________
Впрочем, для любых символов доступно свойство description.

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
alert( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

alert( localSymbol.description ); // name
-----------------------
Системные символы
Существует множество «системных» символов, использующихся внутри самого JavaScript, 
и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице Well-known symbols:

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…и так далее.

В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым 
он будет преобразовываться к примитиву. Мы скоро увидим его применение.

_________________________________________________Преобразование объектов в примитивы____________________________________________

https://learn.javascript.ru/object-toprimitive
Существуют лишь их численные и строковые преобразования!!!
Существуют лишь три варианта хинтов. Не существует хинта со значением «boolean» 
(все объекты являются true в логическом контексте) или каких-либо ещё. 
------
В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:

1.Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive 
(системный символ), если такой метод существует, и передаёт ему хинт.
2.Иначе, если хинт равен "string"
пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
3.В случае, если хинт равен "number" или "default"
пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.
-------
Что произойдёт, если сложить два объекта obj1 + obj2, 
вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?

Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования.
Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции.
 
Например, объекты Date (мы рассмотрим их в статье Дата и время) могут вычитаться, 
и результатом date1 - date2 будет временной отрезок между двумя датами.

Что касается строковых преобразований – они обычно происходят, когда мы выводим 
объект alert(obj), а также в других случаях, когда объект используется как строка.
-------------
записать метод в обьект.
obj[Symbol.toPrimitive] = function(hint) {
  // должен вернуть примитивное значение
  // hint равно чему-то одному из: "string", "number" или "default"
};
______________
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
_____________
Методы toString и valueOf берут своё начало с древних времён. Они не символы, так как в то время символов ещё не существовало,
а просто обычные методы объектов со строковыми именами. Они предоставляют «устаревший» способ реализации преобразований объектов.

Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

toString -> valueOf для хинта со значением «string».
valueOf -> toString – в ином случае.
Для примера, используем их в реализации всё того же объекта user. Воспроизведём его поведение комбинацией методов toString и valueOf:

let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
___________
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
_____________________________________________________________Числа___________________________________________________________________________
Чтобы писать числа с большим количеством нулей:

Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. 
Например: 123e-6 это 0.000123 (123 миллионных).
-----------------------
Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. 
Естественно, есть короткий стиль записи: 0x, после которого указывается число.

alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt
-----------------------
Число в строку
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
-------
Две точки для вызова метода
Внимание! Две точки в 123456..toString(36) это не опечатка. 
Если нам надо вызвать метод непосредственно на числе, как toString в примере выше,
то нам надо поставить две точки .. после числа.
-----------------------
Округление

Math.floor
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
Math.ceil
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
Math.round
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 становится -1.
Math.trunc (не поддерживается в Internet Explorer)
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
-----------------------
Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.

let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round:

let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
Обратите внимание, что результатом toFixed является строка. 
Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
Мы можем преобразовать полученное значение в число, используя унарный оператор + или Number(), 
пример с унарным оператором: +num.toFixed(5). // 12.34
-----------------------
isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

Нужна ли нам эта функция? Разве не можем ли мы просто сравнить === NaN? К сожалению, нет. Значение NaN уникально тем,
что оно не является равным ни чему другому, даже самому себе:

alert( NaN === NaN ); // false
-----------------------
isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

alert( isFinite("") ); // true
alert( isFinite(null) ); // true
alert( isFinite("15") ); // true

alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity

Иногда isFinite используется для проверки, содержится ли в строке число

let num = '12.34px';
console.log(isFinite(num)) // false

let num = '12.34';
console.log(isFinite(num)) // true
-----------------------
Сравнение Object.is
Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.

Этот способ сравнения часто используется в спецификации JavaScript. 
Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, 
он использует Object.is (Определение SameValue).
-----------------------
Число из строки с буквами. 
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
------------
Второй аргумент parseInt(str, radix)
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, 
таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
-----------------------
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math
В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Несколько примеров:

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (любое количество псевдослучайных чисел)
Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
Math.pow(n, power)
Возвращает число n, возведённое в степень power

alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
В объекте Math есть множество функций и констант, включая тригонометрические функции, 
подробнее можно ознакомиться в документации по объекту Math.

____________________________________________________Строки__________________________________________________________

Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.
-----------------------
Длина строки
Свойство length содержит длину строки:

alert( `My\n`.length ); // 3
Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.

length — это свойство
Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: 
они пишут str.length() вместо str.length. Это не работает.

Так как str.length — это числовое свойство, а не функция, добавлять скобки не нужно.
-----------------------
Доступ к символам
Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. 
Также можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию:

let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
-----------------------
Цикл для строк. for of - возвращает именно символ а не индекс как for in

for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}
-----------------------
Изменение регистра
Методы toLowerCase() и toUpperCase() меняют регистр символов:

alert( 'Interface'.toUpperCase() ); // INTERFACE - верхний регистр
alert( 'Interface'.toLowerCase() ); // interface - нижний регистр
Если мы захотим перевести в нижний регистр какой-то конкретный символ:

alert( 'Interface'[0].toLowerCase() ); // 'i'
-----------------------
Найти подстроку в строке. Найти позицию подстроки в строке.

str.indexOf
Первый метод — str.indexOf(substr, pos).

Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию,
на которой располагается совпадение, либо -1 при отсутствии совпадений.

let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, 
начинаем новый поиск со следующей:

let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
Тот же алгоритм можно записать и короче:

let str = "Ослик Иа-Иа посмотрел на виадук";
let target = "Иа";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}

-----------строки------------
str.lastIndexOf(substr, position)
Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.
Он используется тогда, когда нужно получить самое последнее вхождение: 
перед концом строки или начинающееся до (включительно) определённой позиции.
-----------строки------------
Условие if для поиска подстроки в строке
Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т. к. str.indexOf("Widget")
возвращает 0, и if решает, что тест не пройден.
Поэтому надо делать проверку на -1:

let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
    alert("Совпадение есть"); // теперь работает
}
----------строки-------------
str.includes(substr, pos)

Проверить есть ли в строке подстрока. true / false
Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.
Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
----------строки-------------
Проверить начинается\кончается строка.
Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"
----------строки-------------
Получение подстроки. Получить подстроку
В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
substring(start, end)	между start и end	отрицательные значения равнозначны 0
substr(start, length)	length символов, начиная от start	значение start может быть отрицательным

str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );

Если аргумент end отсутствует, slice возвращает символы до конца строки:

let str = "stringify";
alert( str.slice(2) ); // ringify, с позиции 2 и до конца

Также для start/end можно задавать отрицательные значения. Это означает, что позиция 
определена как заданное количество символов с конца строки:

let str = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif
-----------строки------------
str.substring(start [, end])
Возвращает часть строки между start и end.

Это — почти то же, что и slice, но можно задавать start больше end.

Например:

let str = "stringify";

// для substring эти два примера — одинаковы
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// …но не для slice:
alert( str.slice(2, 6) ); // "ring" (то же самое)
alert( str.slice(6, 2) ); // "" (пустая строка)
Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

-----------строки------------
str.substr(start [, length])
Возвращает часть строки от start длины length.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

let str = "stringify";
// ring, получаем 4 символа, начиная с позиции 2
alert( str.substr(2, 4) );
Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

let str = "stringify";
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert( str.substr(-4, 2) );

-----------строки------------
Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. 
Есть специальные методы, позволяющие получить символ по его коду и наоборот.

str.codePointAt(pos)
Возвращает код для символа, находящегося на позиции pos:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90

String.fromCodePoint(code)
Создаёт символ по его коду code

alert( String.fromCodePoint(90) ); // Z
Также можно добавлять юникодные символы по их кодам, используя \u с шестнадцатеричным кодом символа:

// 90 — 5a в шестнадцатеричной системе счисления
alert( '\u005a' ); // Z
Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:

let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
-----------------------
str.trim() — удаляет пробелы в начале и конце строки.
str.repeat(n) — повторить строку n раз.
-----------------------
str.replace(Substr, newSubstr) - заменяет подстроку на новую подстроку.

let str = "Audi cool car";
str = str.replace('Audi', "Mersedes")

console.log(str) // "Mersedes cool car"
-----------------------
Сортировка строк

let str = "ЙЦУКЕЁНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮйцукенгшщзхъфывапроёлджэячсмитьбю"
str = str.split('')

let collator = new Intl.Collator('ru-RU');
console.log(str.sort(collator.compare))
---
---------------------
_____________________________________________________________Массивы___________________________________________________________________________

Массивы для хранения упорядоченных коллекций.

---------Массивы--------------

Обьявление массива.
let arr = new Array();
или
let arr = [];
----------Массивы-------------

Длина массива 
Общее число элементов массива содержится в его свойстве length:

let fruits = ["Яблоко", "Апельсин", "Слива"];

alert( fruits.length ); // 3

----------Массивы-------------

Массивы в JavaScript могут работать и как очередь, и как стек. 
Мы можем добавлять/удалять элементы как в начало, так и в конец массива.
В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

pop
Удаляет последний элемент из массива на месте, и возвращает удаленный эллемент:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин

push
Добавляет элемент в конец массива:

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша

shift
Удаляет из массива первый элемент и возвращает его:

let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удаляем Яблоко и выводим его
alert( fruits ); // Апельсин, Груша

unshift
Добавляет элемент в начало массива:

let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

----------Массивы-------------
Цикл для массивов - for of
for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).

for (let i in arr) – никогда не используйте для массивов!
очистить массив – это arr.length = 0;
---------Массивы--------------
Многомерные массивы
Массивы могут содержать элементы, которые тоже являются массивами. 
Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральный элемент
----------Массивы-------------
toString 
https://learn.javascript.ru/array#tostring
Массивы по-своему реализуют метод toString, который возвращает список элементов, разделённых запятыми.

let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
Давайте теперь попробуем следующее:

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"

Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString, 
таким образом, здесь [] становится пустой строкой, [1] становится "1", а [1,2] становится "1,2".

Когда бинарный оператор плюс "+" добавляет что-либо к строке, он тоже преобразует это в строку, таким образом:

alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"

----------Методы массивов-------------
arr.pop() – извлекает элемент из конца,
arr.push(...items) – добавляет элементы в конец,
arr.shift() – извлекает элемент из начала,
arr.unshift(...items) – добавляет элементы в начало.
-----------------------
Удалить эллементы из массива
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript"]

В следующем примере мы удалим 3 элемента и заменим их двумя другими.
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
----------
splice возвращает массив из удалённых элементов

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 2 первых элемента
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
-----------------------
Вставить эллементы в массив. Добавить в массив
let arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
-----------------------
Получить подмассив

arr.slice([start], [end])

let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

Копировать массив
slice и вообще без аргументов: arr.slice() создаёт копию массива arr
-----------------------
Собрать массив из нескольких массивов и значений
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
arr.concat(arg1, arg2...)
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

------------concat для обьектов-----
Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]

Но если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается
concat как массив: вместо него добавляются его числовые свойства.

Для корректной обработки в объекте должны быть числовые свойства и length:

let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
-----------Методы массивов------------

Перебор: forEach
Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

Его синтаксис:
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});

Например, этот код выведет на экран каждый элемент массива:
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

А этот вдобавок расскажет и о своей позиции в массиве:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
-----------Поиск в массиве------------

Поиск в массиве

arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, 
на котором был найден искомый элемент, в противном случае -1.

arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.
Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является arr.includes.
Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
-----------Поиск в массиве------------

find и findIndex

Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
Здесь пригодится метод arr.find.
Его синтаксис таков:

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});

Функция вызывается по очереди для каждого элемента массива:

item – очередной элемент.
index – его индекс.
array – сам массив.

Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.
--------------
Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Попробуем найти того, кто с id == 1:

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
let user = users.find(item => item.id == 1);
alert(user.name); // Вася

Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, 
а не сам элемент, и -1, если ничего не найдено.
-----------Поиск в массиве------------

filter возвращает массив из всех подходящих элементов.
let results = arr.filter(function(item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});

let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];
// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2
------------
let arr = ['misha', 'vanya', 'petya', 'vasya', 'vartan']

let names = arr.filter(item => item.startsWith('va'))
//вернет["vanya", "vasya", "vartan"]
-----------Преобразование массива------------

map
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map

Метод arr.map является одним из наиболее полезных и часто используемых.
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
Синтаксис:
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});

Например, здесь мы преобразуем каждый элемент в его длину:

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
-----------Cортировка массива------------

sort(fn)
Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
Например:
let arr = [ 1, 2, 15 ];
// метод сортирует содержимое arr
arr.sort();
alert( arr );  // 1, 15, 2
По умолчанию элементы преобризуются и сортируются как строки.

Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
Функция должна для пары значений возвращать:

function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
  }
На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше»,
и отрицательное число, чтобы сказать «меньше».
Это позволяет писать более короткие функции:
let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; }); или arr.sort( (a, b) => a - b );
alert(arr);  // 1, 2, 15
-----------------------
Метод arr.reverse меняет порядок элементов в arr на обратный.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1
Он также возвращает массив arr с изменённым порядком элементов.
-----------------------
Массив из строки

let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}

У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr); // Вася, Петя
--------

Разбивка по буквам

Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert( str.split('') ); // т,е,с,т
-----------------------
Строка из массива
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша
-----------------------
https://learn.javascript.ru/array-methods#reduce-reduceright
reduce/reduceRight
Если нам нужно перебрать массив – мы можем использовать forEach, for или for..of.
Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем map.
Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. 
Они используются для вычисления какого-нибудь единого значения на основе всего массива.
Синтаксис:
let value = arr.reduce(function(previousValue, item, index, array) {// ...}, [initial]);
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
Аргументы:
previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
item – очередной элемент массива,
index – его индекс,
array – сам массив.

Суммирование всех значений массива
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15

Разворачивание массива массивов
var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {
  return a.concat(b);
});
// flattened равен [0, 1, 2, 3, 4, 5]
---
// Для развёртывания многомерных массивов используем рекурсию, reduce и concat
const arr = [1, 2, [3, 4, [5, 6]]];

function flatDeep(arr, d = 1) {
   return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
                : arr.slice();
};

flatDeep(arr, Infinity);
// [1, 2, 3, 4, 5, 6]

-----------------------

Проверить является ли массивом или нет
Array.isArray

Массивы не образуют отдельный тип языка. Они основаны на объектах.
Поэтому typeof не может отличить простой объект от массива:

alert(typeof {}); // object
alert(typeof []); // тоже object

…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). 
Он возвращает true, если value массив, и false, если нет.

alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
-----------------------

Большинство методов поддерживают «thisArg»
Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort,
принимают необязательный параметр thisArg.

Вот полный синтаксис этих методов:
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
Значение параметра thisArg становится this для func.

Например, вот тут мы используем метод объекта army как фильтр, и thisArg передаёт ему контекст:

let army = {
  minAge: 1,
  maxAge: 5,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let obj = {
  minAge: 5, 
  maxAge: 10
};

let users = [
  {age: 1},
  {age: 3},
  {age: 6},
  {age: 7}
];

// найти пользователей, для которых army.canJoin возвращает true

let soldiers = users.filter(army.canJoin, obj);
// console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 6
console.log(soldiers[1].age); // 7

или обращаемся к другому обьекту для получения других значений this
let soldiers = users.filter(army.canJoin, army);
// console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 1
console.log(soldiers[1].age); // 3
-----------------------
Сгенерировать массив
--
let arr = new Array(4).fill(null);
console.log(arr) // [null, null, null, null]
--
let arr = new Array(4).fill(null).map( ()=> Math.floor( Math.random() * 30 ) - 10);
console.log(arr.sort( (a,b) => a - b )) // [-3, -2, 6, 13]


_____________________________________________________________Перебираемые объекты___________________________________________________________________________
https://learn.javascript.ru/iterable#array-from
Symbol.iterator

let range = {
  from: 1,
  to: 5,
  [Symbol.iterator]: function(){
    return  {
      current: this.from,
      last: this.to,
      
      next() {
        if (this.current <= this.last) {
          return {done: false, value: this.current++};
        }else {
          return {done: true};
        }
      }
    }
  }
};

// for(key of range) {
//   console.log(key);
// }


let a = range[Symbol.iterator]();

console.log(a.next());
-----------------------
Итератор строк

let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
-----------------------
Итерируемые объекты и псевдомассивы
Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы.
Array.from - Перевести в массив______.

let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
--------------------------
// range взят из примера выше
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (преобразование массива через toString работает)
---------------------------
Из обьекта в псевдомассив

let obj = {
  name: 'Jon',
  surname: 'Smith',
  age: 22
};

let obj2 = Object.fromEntries(Object.values(obj).map((item, index) => [index, item]) )
obj.length = Object.keys(obj).length
console.log(obj2)

_____________________________________________________________Map________________________________________________________________

Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные 
коллекции,но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

Map
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:

new Map() – создаёт коллекцию.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.
--------------
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3
--------------
Map может использовать объекты в качестве ключей.

let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
--------------
Цепочка вызовов
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:

map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
--------------
Перебор Map.  Цикл для Map for of
Для перебора коллекции Map есть 3 метода:

map.keys() – возвращает итерируемый объект по ключам,
map.values() – возвращает итерируемый объект по значениям,
map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
Например:

let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}
--------------
Используется порядок вставки
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.

Кроме этого, Map имеет встроенный метод forEach, схожий со встроенным методом массивов Array:

// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});
--------------
Создать заполненный Map.
При создании Map мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:

// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
-------
Object.entries: Map из Object ----- Map из обьекта.  Из обьекта в Map

Если у нас уже есть обычный объект, и мы хотели бы создать Map из него, то поможет
встроенный метод Object.entries(obj), который получает объект и возвращает массив пар 
ключ-значение для него, как раз в этом формате.
Так что мы можем создать Map из обычного объекта следующим образом:

let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

Здесь Object.entries возвращает массив пар ключ-значение: [ ["name","John"], ["age", 30] ].
Это именно то, что нужно для создания Map.
--------------
Object.fromEntries: Object из Map ----- Из Map в обьект.

Метод Object.fromEntries, получив массив пар вида [ключ, значение], создаёт из них объект:

let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
--------------
Мы можем использовать Object.fromEntries, чтобы получить обычный объект из Map.

К примеру, у нас данные в Map, но их нужно передать в сторонний код, который ожидает обычный объект.
Вот как это сделать:

let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
Вызов map.entries() возвращает массив пар ключ/значение, как раз в нужном формате для Object.fromEntries.
Мы могли бы написать строку (*) ещё короче:

let obj = Object.fromEntries(map); // убрать .entries()

Это то же самое, так как Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив.
А перебор map как раз возвращает пары ключ/значение, так же, как и map.entries(). Так что в итоге у нас будет обычный
объект с теми же ключами/значениями, что и в map.
_____________________________________________________________Set___________________________________________________________________________
Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен 
итерируемый объект (обычно это массив), то копирует его значения в новый Set.

set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.

Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением
ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.
--------------
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}
--------------
Перебор объекта Set
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach:

let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});

Заметим забавную вещь. Функция в forEach у Set имеет 3 аргумента: значение value, потом сновато же самое 
значение valueAgain, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом Map, в котором колбэк forEach имеет 3 аргумента. Выглядит немного странно,
но в некоторых случаях может помочь легко заменить Map на Set и наоборот.

Set имеет те же встроенные методы, что и Map:

set.values() – возвращает перебираемый объект для значений,
set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

--------------------------------------Перевод из одной структуры в другую---------------------------------
Obj to Arr
let obj = {
  name: "jon",
  subname: "Smit",
  age: 18,
};

let arr = Object.keys(obj); // ["name", "subname", "age"]
let arr = Object.values(obj); // ["jon", "Smit", 18]
let arr = Object.entries(obj); // [["name", "jon"], ["subname", "Smit"], ["age", 18]]
--------------
Obj to Map
let map = new Map(Object.entries(obj));//Array.from(map) // [["name", "jon"], ["subname", "Smit"], ["age", 18]]
--------------
Map to Obj
let obj = Object.fromEntries(map.entries());
--------------
Map to Arr
Array.from( map.values() )// ["jon", "Smit", 18]
Array.from( map.keys() )// ["name", "subname", "age"]
Array.from( map.entries() )// [["name", "jon"], ["subname", "Smit"], ["age", 18]]
-------------
Arr to Obj
let arr = [["name", "jon"], ["subname", "Smit"], ["age", 18]]
obj2 = Object.fromEntries(arr) // {age: 18, name: "jon", subname: "Smit"};
-------------
Arr to Map
let map2 = new Map(arr) // arr должен иметь вид [["name", "jon"], ["subname", "Smit"], ["age", 18]];
----
let map2 = new Map( arr.entries() );//[[0, ["name", "jon"]], [1, ["subname", "Smit"]], [2, ["age", 18]]]

_____________________________________________________________WeakMap___________________________________________________________________________

WeakMap
Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, 
то он будет удалён из памяти (и из объекта WeakMap) автоматически.

let john = { name: "John" };
let weakMap = new WeakMap();
weakMap.set(john, "...");
john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
------------
В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)
----------------
Предположим, у нас есть код, который ведёт учёт посещений для пользователей. 
Информация хранится в коллекции WeakMap: объект, представляющий пользователя, 
является ключом, а количество визитов – значением. Когда пользователь нас покидает 
(его объект удаляется сборщиком мусора),то больше нет смысла хранить соответствующий счётчик посещений.

// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}

А вот другая часть кода, возможно, в другом файле, которая использует countUser:

// 📁 main.js
let john = { name: "John" };

countUser(john); //ведём подсчёт посещений
console.log(visitsCountMap.get(jon))

// пользователь покинул нас
john = null;
Теперь объект john должен быть удалён сборщиком мусора
----------------
Применение для кеширования
Другая частая сфера применения – это кеширование, когда результат вызова функции
должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы 
на том же объекте могли просто брать уже готовый результат,
повторно используя его.

let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются

_____________________________________________________________WeakSet___________________________________________________________________________
Коллекция WeakSet ведёт себя похоже:

Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища.
Но не для произвольных данных, а скорее для значений типа «да/нет». 
Присутствие во множестве WeakSet может что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически

Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое.
Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять 
их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.



______________________________________________Object.keys, values, entries_____________________________________________________
Для простых объектов доступны следующие методы:

Object.keys(obj) – возвращает массив ключей.
Object.values(obj) – возвращает массив значений.
Object.entries(obj) – возвращает массив пар [ключ, значение].
-----------
Object.keys/values/entries игнорируют символьные свойства
Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.

Обычно это удобно. Но если требуется учитывать и символьные ключи, то для этого существует отдельный метод 
Object.getOwnPropertySymbols,возвращающий массив только символьных ключей. Также, существует метод
Reflect.ownKeys(obj), который возвращает все ключи.
--------------
Трансформации объекта
У объектов нет множества методов, которые есть в массивах, например map, filter и других.

Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
На нём вызываем методы массива, например, map.
Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
Это может выглядеть сложным на первый взгляд, 
но становится лёгким для понимания после нескольких раз использования.

Можно делать и более сложные «однострочные» преобразования таким путём. Важно только сохранять баланс, 
чтобы код при этом был достаточно простым для понимания.


_____________________________________________________Деструктурирующее присваивание_____________________________________________
Деструктуризация массива
Пример деструктуризации массива:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
Теперь мы можем использовать переменные вместо элементов массива.

Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');
------------------------
Пропускайте элементы, используя запятые
Ненужные элементы массива также могут быть отброшены через запятую:

// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
В примере выше второй элемент массива пропускается, а третий присваивается переменной title, 
оставшиеся элементы массива также пропускаются (так как для них нет переменных).
---------------------
Работает с любым перебираемым объектом с правой стороны
…На самом деле мы можем использовать любой перебираемый объект, не только массивы:

let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);

Присваивайте чему угодно с левой стороны
Мы можем использовать что угодно «присваивающее» с левой стороны.

Например, можно присвоить свойству объекта:

let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
----------------------
Цикл с .entries()
В предыдущей главе мы видели метод Object.entries(obj).

Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
…то же самое для map:

let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
---------------------
Остаточные параметры «…»
Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр,
  который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// Обратите внимание, что `rest` является массивом.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
---------------
Значения по умолчанию
Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
Если нам необходимо указать значения по умолчанию, то мы можем использовать =:

// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)
Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. 
Они выполняются, только если значения отсутствуют.

Например, здесь мы используем функцию prompt для указания двух значений по умолчанию. Но она будет запущена только для отсутствующего значения:

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // результат prompt
------------------
Деструктуризация объекта
Деструктурирующее присваивание также работает с объектами.

Синтаксис:

let {var1, var2} = {var1:…, var2:…}
У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные.
Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}.

Например:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Свойства options.title, options.width и options.height присваиваются соответствующим переменным. 
Порядок не имеет значения. Вот так – тоже работает:

// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.

Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width 
присвоить переменной w, то мы можем использовать двоеточие:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height 
сохраняется в h, а title присваивается одноимённой переменной.

Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь:

let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. 
Они выполнятся, если значения отсутствуют.

В коде ниже prompt запросит width, но не title:

let options = {
  title: "Menu"
};

let {width = prompt("width?"), title = prompt("title?")} = options;

alert(title);  // Menu
alert(width);  // (результат prompt)
Мы также можем совмещать : и =:

let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно:

let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// взять только title, игнорировать остальное
let { title } = options;

alert(title); // Menu
------------------------
Вложенная деструктуризация
Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более
сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.

В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. 
Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:

let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut

Весь объект options, кроме свойства extra, которое в левой части отсутствует, присваивается в соответствующие переменные:
В итоге у нас есть width, height, item1, item2 и title со значением по умолчанию.
Заметим, что переменные для size и items отсутствуют, так как мы взяли сразу их содержимое.
-----------------
Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные

function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
--------------------------
Мы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием:

let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
--------------------
Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() 
будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:

showMenu({}); // ок, все значения - по умолчанию

showMenu(); // так была бы ошибка
Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров:

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.

_____________________________________________________________Дата и Время____Date_______________________________________________________________________

let now = new Date();
alert( now ); // показывает текущие дату и время let now = new Date();
---------------------
new Date(milliseconds)
Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстамп (англ. timestamp).

Это – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью new Date(timestamp) и 
наоборот преобразовать существующий объект Date в таймстамп, используя метод date.getTime() (см. ниже).
---------------------
new Date(datestring)
Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же,
как в Date.parse, который мы рассмотрим позже.

let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
---------------------
new Date(year, month, date, hours, minutes, seconds, ms)
Создать объект Date с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.

year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
month начинается с 0 (январь) по 11 (декабрь).

Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.
Например:

new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0

Максимальная точность – 1 мс (до 1/1000 секунды):
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
---------------------
Получение компонентов даты
Существуют методы получения года, месяца и т.д. из объекта Date:

getFullYear() - Получить год (4 цифры)
getMonth() - Получить месяц, от 0 до 11.
getDate() - Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
getDay() - Вернуть день недели от 0 (воскресенье) до 6 (суббота).
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Получить, соответственно, часы, минуты, секунды или миллисекунды.
---------------------
Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.
Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: 
getUTCFullYear(), getUTCMonth(), getUTCDay(). Для их использования требуется после "get" подставить "UTC".

Если ваш местный часовой пояс смещён относительно UTC, то следующий код покажет разные часы:

// текущая дата
let date = new Date();

// час в вашем текущем часовом поясе
alert( date.getHours() );

// час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)
alert( date.getUTCHours() );
---------------------

Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

getTime()
Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

getTimezoneOffset()
Возвращает разницу в минутах между местным часовым поясом и UTC:

// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
alert( new Date().getTimezoneOffset() );
---------------------

Установка компонентов даты
https://learn.javascript.ru/date#ustanovka-komponentov-daty
Следующие методы позволяют установить компоненты даты и времени:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

Как мы видим, некоторые методы могут устанавливать сразу несколько компонентов даты, например: 
setHours. Если какая-то компонента не указана, она не меняется.

let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00.
---------------------
Автоисправление даты
let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // задать первое число месяца
alert( date );

date.setDate(0); // первый день месяца -- это 1, так что выводится последнее число предыдущего месяца
alert( date ); // 31 Dec 2015
---------------------
Date.now()
Если нужно просто измерить время, объект Date нам не нужен.
Существует особый метод Date.now(), возвращающий текущую метку времени.
Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. 
Так что этот способ работает быстрее и не нагружает сборщик мусора.
Данный метод используется из соображений удобства или когда важно быстродействие, например, 
при разработке игр на JavaScript или других специализированных приложений.

let start = Date.now(); // количество миллисекунд с 1 января 1970 года

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` ); // вычитаются числа, а не даты
---------------------
Бенчмаркинг
https://learn.javascript.ru/date#benchmarking

function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// bench(upperSlice) и bench(upperLoop) поочерёдно запускаются 10 раз
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Итоговое время diffSubtract: ' + time1 );
alert( 'Итоговое время diffGetTime: ' + time2 );
---------------------
Разбор строки с датой
Метод Date.parse(str) считывает дату из строки.

Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:

YYYY-MM-DD – это дата: год-месяц-день.
Символ "T" используется в качестве разделителя.
HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.
Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп 
(количество миллисекунд с 1 января 1970 года UTC+0).
Если формат неправильный, возвращается NaN.

Например:

let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)
Можно тут же создать объект new Date из таймстампа:

let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);

__________________________________________________Формат JSON, метод toJSON_______________________________________________________
JSON.stringify для преобразования объектов в JSON.
JSON.parse для преобразования JSON обратно в объект.

------JSON.stringify------

let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* вся структура преобразована в строку:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
----------
JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify
пропускает некоторые специфические свойства объектов JavaScript.

А именно:

Свойства-функции (методы).
Символьные свойства.
Свойства, содержащие undefined.
let user = {
  sayHi() { // будет пропущено
    alert("Hello");
  },
  [Symbol("id")]: 123, // также будет пропущено
  something: undefined // как и это - пропущено
};

alert( JSON.stringify(user) ); // {} (пустой объект)
---------------
Важное ограничение: не должно быть циклических ссылок.

Например:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup ссылается на room
room.occupiedBy = meetup; // room ссылается на meetup

JSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON
Здесь преобразование завершается неудачно из-за циклической ссылки: room.occupiedBy ссылается на meetup, 
и meetup.place ссылается на room:
---->
Исключаем и преобразуем: replacer
Полный синтаксис JSON.stringify:

let json = JSON.stringify(value[, replacer, space])
value
Значение для кодирования.
replacer
Массив свойств для кодирования или функция соответствия function(key, value).
space
Дополнительное пространство (отступы), используемое для форматирования.

Давайте включим в список все свойства, кроме room.occupiedBy, из-за которого появляется цикличная ссылка:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
------>
Теперь всё, кроме occupiedBy, сериализовано. Но список свойств довольно длинный.

К счастью, в качестве replacer мы можем использовать функцию, а не массив.

Функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение, 
которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.

В нашем случае мы можем вернуть value «как есть» для всего, кроме occupiedBy. Чтобы игнорировать occupiedBy,
код ниже возвращает undefined:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup ссылается на room
};

room.occupiedBy = meetup; // room ссылается на meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* пары ключ:значение, которые приходят в replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
Обратите внимание, что функция replacer получает каждую пару ключ/значение, включая вложенные объекты и элементы массива.
И она применяется рекурсивно. Значение this внутри replacer – это объект, который содержит текущее свойство.

Первый вызов – особенный. Ему передаётся специальный «объект-обёртка»: {"": meetup}. Другими словами, первая (key, value) 
пара имеет пустой ключ, а значением является целевой объект в общем.
Вот почему первая строка из примера выше будет ":[object Object]".

Идея состоит в том, чтобы дать как можно больше возможностей replacer – у него есть возможность 
проанализировать и заменить/пропустить даже весь объект целиком, если это необходимо.
---------------
Форматирование: space
Третий аргумент в JSON.stringify(value, replacer, space) – это количество пробелов,
используемых для удобного форматирования.

Ранее все JSON-форматированные объекты не имели отступов и лишних пробелов. 
Это нормально, если мы хотим отправить объект по сети. Аргумент space 
используется исключительно для вывода в удобочитаемом виде.

Ниже space = 2 указывает JavaScript отображать вложенные объекты 
в несколько строк с отступом в 2 пробела внутри объекта:

let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* отступ в 2 пробела:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* для JSON.stringify(user, null, 4) результат содержит больше отступов:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
Параметр space применяется для логирования и красивого вывода.
---------------
Пользовательский «toJSON»
Как и toString для преобразования строк, объект может предоставлять метод toJSON 
для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.

Например:

let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
Как видим, date (1) стал строкой. Это потому, что все объекты типа Date имеют
встроенный метод toJSON, который возвращает такую строку.

Теперь давайте добавим собственную реализацию метода toJSON в наш объект room (2):

let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
Как видите, toJSON используется как при прямом вызове JSON.stringify(room),
так и когда room вложен в другой сериализуемый объект.
---------------
JSON.parse
Чтобы декодировать JSON-строку, нам нужен другой метод с именем JSON.parse.

Синтаксис:

let value = JSON.parse(str, [reviver]);
str
JSON для преобразования в объект.
reviver
Необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение.
Например:

// строковый массив
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
Или для вложенных объектов:

let user = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

user = JSON.parse(user);

alert( user.friends[1] ); // 1
------>
Использование reviver
Давайте передадим JSON.parse функцию восстановления вторым аргументом, которая возвращает 
все значения «как есть», но date станет Date:

let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // 30 - теперь работает!
Кстати, это работает и для вложенных объектов:

let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // 18 - отлично!

______________________________________________________Рекурсия и стек________________________________________________

https://learn.javascript.ru/recursion#vyvod-odnosvyaznogo-spiska-v-obratnom-poryadke

Фебоначи

function feb(n) {
  let a = 1, b = 1, c;
  
  for (let i = 3; i <= n; i++) {
    c = a + b;
    
    a = b;
    b = c;
    
  }
  return b;
}

console.log(feb(7))

_____________________________________Остаточные параметры и оператор расширения_______________________________________
Остаточные параметры (...)
Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.

Например:

function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.

Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся 
параметры и положи их в массив».
---------------
Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.

В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в массив titles:

function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Юлий Цезарь

  // Оставшиеся параметры пойдут в массив
  // titles = ["Консул", "Император"]
  alert( titles[0] ); // Консул
  alert( titles[1] ); // Император
  alert( titles.length ); // 2
}

showName("Юлий", "Цезарь", "Консул", "Император");
---------------
Остаточные параметры должны располагаться в конце
Остаточные параметры собирают все остальные аргументы, поэтому бессмысленно писать что-либо после них. Это вызовет ошибку:

function f(arg1, ...rest, arg2) { // arg2 после ...rest ?!
  // Ошибка
}
...rest должен всегда быть последним.
------------------
Стрелочные функции не имеют "arguments" (и this);
Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.

Переменная "arguments"
Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.

Например:

function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // Объект arguments можно перебирать
  // for (let arg of arguments) alert(arg);
}

// Вывод: 2, Юлий, Цезарь
showName("Юлий", "Цезарь");

// Вывод: 1, Илья, undefined (второго аргумента нет)
showName("Илья");

Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments.
Этот способ всё ещё работает, мы можем найти его в старом коде.

Но у него есть один недостаток. Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив. 
Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).

К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. 
А остаточные параметры позволяют это сделать.

Соответственно, для более удобной работы с аргументами лучше использовать остаточные параметры.
-----------------

Оператор расширения
Мы узнали, как получить массив из списка параметров.

Но иногда нужно сделать в точности противоположное.

Например, есть встроенная функция Math.max. Она возвращает наибольшее число из списка:

Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

Для Math.max:

let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)
Этим же способом мы можем передать несколько итерируемых объектов:

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
Мы даже можем комбинировать оператор расширения с обычными значениями:

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
Оператор расширения можно использовать и для слияния массивов:

let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, 
но он работает с любым перебираемым объектом.

----------------------

Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:

let str = "Привет";

alert( [...str] ); // П,р,и,в,е,т
Посмотрим, что происходит. Под капотом оператор расширения использует итераторы, 
чтобы перебирать элементы. Так же, как это делает for..of.

Цикл for..of перебирает строку как последовательность символов, поэтому из ...str 
получается "П", "р", "и", "в", "е", "т". Получившиеся символы собираются в массив при помощи 
стандартного объявления массива: [...str].

Для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив:

let str = "Привет";

// Array.from преобразует перебираемый объект в массив
alert( Array.from(str) ); // П,р,и,в,е,т
Результат аналогичен [...str].

Но между Array.from(obj) и [...obj] есть разница:

Array.from работает как с псевдомассивами, так и с итерируемыми объектами
Оператор расширения работает только с итерируемыми объектами
Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
----------------
Итого
Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.

Как отличить их друг от друга:

Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные
аргументы и делает из них массив.
Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
Полезно запомнить:

Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.

К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

_______________________________________________________Замыкание_____________________________________________________________
https://learn.javascript.ru/closure

Один вызов – одно лексическое окружение
Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, 
специфичными для этого вызова, локальными переменными и параметрами.
-------------
Замыкания
В программировании есть общий термин: «замыкание», – которое должен знать каждый разработчик.

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание.
Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями 
(есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они
могут получить доступ к внешним переменным.

Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным
ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются
замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, 
как работает лексическое окружение.
-------------
Блоки кода и циклы, IIFE
https://learn.javascript.ru/closure#bloki-koda-i-tsikly-iife

________________________________________________Устаревшее ключевое слово ___var________________________________________________
Для «var» не существует блочной области видимости
Область видимости переменных var ограничивается либо функцией,
либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.

Переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того,
в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).

Объявление переменной обрабатывается в начале выполнения функции («всплывает»), однако присвоение значения 
всегда происходит в той строке кода, где оно указано. Т.е. код выполняется по следующему сценарию:

function sayHi() {
  var phrase; // объявление переменной срабатывает вначале...

  alert(phrase); // undefined

  phrase = "Привет"; // ...присвоение - в момент, когда исполнится данная строка кода.
}

sayHi();

Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться на них в любом месте. 
Однако, переменные имеют значение undefined до строки с присвоением значения.

В обоих примерах выше вызов alert происходил без ошибки, потому что переменная phrase уже существовала. 
Но её значение ещё не было присвоено, поэтому мы получали undefined.

__________________________________________________________Глобальный объект_________________________________________________________
https://learn.javascript.ru/global-object
Итого
Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, 
window.innerHeight – высота окна браузера.

Глобальный объект имеет универсальное имя – globalThis.

…Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window 
(браузер) и global (Node.js). Так как globalThis появился недавно, он не поддерживается в IE и Edge (не-Chromium версия),
но можно использовать полифил.

Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться
свести их количество к минимуму.

В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся 
свойствами глобального объекта.

Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта 
напрямую, как window.x.
______________________________________________________Объект функции, NFE_________________________________________________
Итого
Функции – это объекты.

Их свойства:

name – имя функции. Обычно берётся из объявления функции, но если там нет – JavaScript пытается понять его из контекста.
length – количество аргументов в объявлении функции. Троеточие («остаточные параметры») не считается.
Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это называется 
Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же,
для рекурсивных вызовов и т.п.

Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.

Они создают «основную» функцию и добавляют множество «вспомогательных» функций внутрь первой. Например, библиотека 
jQuery создаёт функцию с именем $. Библиотека lodash создаёт функцию _, а потом добавляет в неё _.clone, _.keyBy и 
другие свойства (чтобы узнать о ней побольше см. документацию). Они делают это, чтобы уменьшить засорение глобального 
пространства имён посредством того, что одна библиотека предоставляет только одну глобальную переменную, 
уменьшая вероятность конфликта имён.

Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезную функциональность 
через свои свойства.

__________________________________________Синтаксис "new Function"___________________________________________________

function print() {
  let value = "vooou";
  return new Function("console.log(value)");  
}

window.value = "holla";

print()() // "holla"
-------
Итого
Синтаксис:

let func = new Function ([arg1, arg2, ...argN], functionBody);
По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

Эти 3 объявления ниже эквивалентны:

new Function('a', 'b', 'return a + b'); // стандартный синтаксис
new Function('a,b', 'return a + b'); // через запятую в одной строке
new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке

Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое окружение,
а не на родительское. Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому 
что страхует нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает 
проблем у минификаторов.
____________________________________________Планирование: setTimeout и setInterval_____________________________________________
https://learn.javascript.ru/settimeout-setinterval

setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
---

Отмена через clearTimeout

let timerId = setTimeout(...);
clearTimeout(timerId)
---

Отмена через clearInterval

let timerId = setInterval(() => alert('tick'), 2000);
// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

------------
let tick = setInterval( (a) => console.log(a), 1000, "a + b");
setTimeout( () => { clearInterval(tick); console.log("stop"); }, 5000 )

Пять раз выполнится "a + b" затем остановится;
-----------
рекурсивный setTimeout:

let i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);

Рекурсивныйse
tTimeout гарантирует фиксированную задержку между вызовами функции, дожедаясь ее выполнения.
В отилчии от setInterval которая не учитывает время выполнения функции.
-----------
setTimeout с нулевой задержкой
этот код выводит «Привет» и затем сразу «Мир»:

setTimeout(() => alert("Мир"));
alert("Привет");

Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь» только 
после того, как текущий код завершится.Поэтому "Привет" выводится первым, а "Мир" – после него.
----------
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова

  if (start + 100 < Date.now()) alert(times); // показываем задержку через 100 мс
  else setTimeout(run); // если нужно ещё запланировать
});

// пример вывода:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100

Первый таймер запускается сразу (как и указано в спецификации), а затем задержка вступает в игру, и мы видим 9, 15, 20, 24....
Аналогичное происходит при использовании setInterval вместо setTimeout: setInterval(f) запускает f несколько раз с 
нулевой задержкой, а затем с задержкой 4+ мс.
--------------
Итого

Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют выполнять func регулярно
или только один раз после задержки delay, заданной в мс.

Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, 
которое возвращают методы setInterval/setTimeout.

Вложенный вызов setTimeout является более гибкой альтернативой setInterval. 
Также он позволяет более точно задать интервал между выполнениями.
Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, setTimeout(func) используется для вызовов, 
которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами setTimeout,
а также для setInterval, начиная с 5-го вызова.
Обратим внимание, что все методы планирования не гарантируют точную задержку.

Например, таймер в браузере может замедляться по многим причинам:

Перегружен процессор.
Вкладка браузера в фоновом режиме.
Работа ноутбука от аккумулятора.
Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 
300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС

_____________________________________________Декораторы и переадресация вызова, call/apply___________________________________
https://learn.javascript.ru/call-apply-decorators

-----------
func.call(context, arg1, arg2, ...) - сразу вызывает функцию; принимает безконечное число параметров списком.

Он запускает функцию func, используя первый аргумент как её контекст this, а последующие – как её аргументы.
Проще говоря, эти два вызова делают почти то же самое:
-----------
func.apply(context, args) - сразу вызывает функцию; принимает только два параметра; args - только в виде массива;

Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.
Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов, 
в то время как apply принимает псевдомассив.
-----------
Заимствование метода у массива.

function hash() {
  alert( [].join.call(arguments) ); // 1,2
}
hash(1, 2);
-------------
Перенаправление вызова

Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (call forwarding).
Простейший вид такого перенаправления:

let wrapper = function() {
  return func.apply(this, arguments);
};
При вызове wrapper из внешнего кода его не отличить от вызова исходной функции.
-----------------
Переадресация вызова
В основном переадресация вызова выполняется с помощью apply:

let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};
________________________________________Привязка контекста к функции bind_______________________________________

Потеря «this»

Как только метод передаётся отдельно от объекта – this теряется.
Вот как это может произойти в случае с setTimeout:

let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Привет, undefined!

Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user 
(именно здесь функция и потеряла контекст). 
То есть последняя строка может быть переписана как:

let f = user.sayHi;
setTimeout(f, 1000); // контекст user потеряли

Решение 1: сделать функцию-обёртку
Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:

setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
-------------------

let bound = func.bind(context, [arg1], [arg2], ...); возвращает функцию не вызывая ее; привязывает this и аргументы; 

Аргументы это не обязательный параметр можно просто 
let bound = func.bind(context)
-------------------
Частичное применение

function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2); // привязываем только аргумент; контекст = null;

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10

Вызов mul.bind(null, 2) создаёт новую функцию double, которая передаёт вызов mul, 
фиксируя null как контекст, и 2 – как первый аргумент. Следующие аргументы передаются как есть.
Это называется частичное применение – мы создаём новую функцию, фиксируя некоторые из существующих параметров.
Обратите внимание, что в данном случае мы на самом деле не используем this. Но для bind это обязательный параметр, 
так что мы должны передать туда что-нибудь вроде null.
-------------------
Частичное применение без контекста
https://learn.javascript.ru/bind#chastichnoe-primenenie-bez-konteksta
-------------------
Итого
Метод bind возвращает «привязанный вариант» функции func, фиксируя контекст this и первые аргументы arg1, arg2…, если они заданы.

Обычно bind применяется для фиксации this в методе объекта, чтобы передать его в качестве колбэка. Например, для setTimeout.

Когда мы привязываем аргументы, такая функция называется «частично применённой» или «частичной».

Частичное применение удобно, когда мы не хотим повторять один и тот же аргумент много раз. 
Например, если у нас есть функция send(from, to) и from всё время будет одинаков для нашей задачи, 
то мы можем создать частично применённую функцию и дальше работать с ней.
------------------
______________________________________Повторяем стрелочные функции___________________________________________
https://learn.javascript.ru/arrow-functions

Итого
Стрелочные функции:

Не имеют this.
Не имеют arguments.
Не могут быть вызваны с new.
(У них также нет super, но мы про это не говорили. Про это будет в главе Наследование классов).
Всё это потому, что они предназначены для небольшого кода, который не имеет своего «контекста», выполняясь в текущем.
И они отлично справляются с этой задачей!


_____________________________________Флаги и дескрипторы свойств______________________________________
Флаги свойств
Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

writable – если false, нельзя изменить так obj.key = value, *но свойство можно изменить через Object.defineProperty;

enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.

configurable – если false, нельзя удалить, (можно изменить value и writable только один раз на false
если на момент установки configurable = false одновременно было установленно writable = true, обратно вернуть нельзя) ,
нельзя изменить enymerable и configurable;

Мы ещё не встречали эти атрибуты, потому что обычно они скрыты. Когда мы создаём свойство «обычным способом», 
все они имеют значение true. Но мы можем изменить их в любое время.
-------------
let user = {
  name: "John"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name'); - информация о этих трех флагах свойства;
-------------
 Object.getOwnPropertyDescriptors(obj) - информация о флагах всех свойств обьекта;
-------------
Если свойство существует, defineProperty обновит его флаги. В противном случае метод создаёт новое свойство
с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.

Например, здесь создаётся свойство name, все флаги которого имеют значение false:

let user = {};

Object.defineProperty(user, "name", {
  value: "John"
});
-------------
Таким образом, мы можем определить множество свойств одной операцией.

Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
  // ...
});
-------------
Клонирование обьекта со всеми флагами и символьными свойствами.

Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).

Вместе с Object.defineProperties этот метод можно использовать для клонирования объекта вместе с его флагами:

let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
Обычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства:

for (let key in user) {
  clone[key] = user[key]
}
…Но это не копирует флаги. Так что если нам нужен клон «получше», предпочтительнее использовать Object.defineProperties.

Другое отличие в том, что for..in игнорирует символьные свойства, а Object.getOwnPropertyDescriptors возвращает дескрипторы 
всех свойств, включая свойства-символы.
-------------
Глобальное запечатывание объекта
Дескрипторы свойств работают на уровне конкретных свойств.

Но ещё есть методы, которые ограничивают доступ ко всему объекту:

Object.preventExtensions(obj)
Запрещает добавлять новые свойства в объект.

Object.seal(obj)
Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.

Object.freeze(obj)
Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.
А также есть методы для их проверки:

Object.isExtensible(obj)
Возвращает false, если добавление свойств запрещено, иначе true.

Object.isSealed(obj)
Возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.

Object.isFrozen(obj)
Возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств
установлено configurable: false, writable: false.

На практике эти методы используются редко.


____________________________________Свойства - геттеры и сеттеры________________________________________

let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },

  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

--------------
(get)

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

alert(user.fullName); // John Smith

Снаружи свойство-аксессор выглядит как обычное свойство. В этом и заключается смысл свойств-аксессоров. 
Мы не вызываем user.fullName как функцию, а читаем как обычное свойство: геттер выполнит всю работу за кулисами.
--------------
(set)

let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// set fullName запустится с данным значением
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper
--------------
Дескрипторы свойств доступа
Дескрипторы свойств-аксессоров отличаются от «обычных» свойств-данных.

Свойства-аксессоры не имеют value и writable, но взамен предлагают функции get и set.

То есть, дескриптор аксессора может иметь:

get – функция без аргументов, которая сработает при чтении свойства,
set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
enumerable – то же самое, что и для свойств-данных,
configurable – то же самое, что и для свойств-данных.
Например, для создания аксессора fullName при помощи defineProperty мы можем передать дескриптор с использованием get и set:

let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
Ещё раз заметим, что свойство объекта может быть либо свойством-аксессором (с методами get/set), 
либо свойством-данным (со значением value).

При попытке указать и get, и value в одном дескрипторе будет ошибка:
--------------
Умные геттеры/сеттеры
Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, 
чтобы получить больше контроля над операциями с ними.

Например, если мы хотим запретить устанавливать короткое имя для user, мы можем использовать сеттер name для проверки,
а само значение хранить в отдельном свойстве _name:

let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое, должно быть более 4 символов");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = ""; // Имя слишком короткое...
Таким образом, само имя хранится в _name, доступ к которому производится через геттер и сеттер.

Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью user._name, 
но существует широко известное соглашение о том, что свойства, которые начинаются с символа "_", 
являются внутренними, и к ним не следует обращаться из-за пределов объекта.
--------------
Создание геттера в конструкторе

function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // возраст рассчитывается из текущей даты и дня рождения
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // доступен как день рождения
alert( john.age );      // ...так и возраст
Теперь старый код тоже работает, и у нас есть отличное дополнительное свойство!


_________________________________________Прототипное наследование_________________________________
https://learn.javascript.ru/prototype-inheritance

[[Prototype]]
В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), 
которое либо равно null, либо ссылается на другой объект «прототип»;
------------
Есть только два ограничения:

Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
Значение __proto__ может быть объектом или null. Другие типы игнорируются.
Это вполне очевидно, но всё же: может быть только один [[Prototype]]. Объект не может наследоваться от двух и более других объектов.

Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

----------------------
Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода 
obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

Пример такой фильтрации:

let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Our: ${prop}`); // Our: jumps
  } else {
    alert(`Inherited: ${prop}`); // Inherited: eats
  }
}
--------------
Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства
Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values 
и другие – игнорируют унаследованные свойства.
Они учитывают только свойства самого объекта, не его прототипа.

_____________________________________________F.prototype_________________________________________________
Прототип в конструкторах.

Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().
Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
------------

Обратите внимание, что F.prototype означает обычное свойство с именем "prototype" для F. Это ещё не «прототип объекта», 
а обычное свойство F с таким именем.

Приведём пример:

let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true

Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: 
"При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".
-------------
F.prototype используется только в момент вызова new F()
F.prototype используется только при вызове new F() и присваивается в качестве свойства [[Prototype]] нового объекта.
После этого F.prototype и новый объект ничего не связывает. Следует понимать это как «единоразовый подарок» объекту.

После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(), будут иметь другой объект в 
качестве [[Prototype]], но уже существующие объекты сохранят старый.
-------------
function Rabbit() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true

let rabbit = new Rabbit(); // наследует от {constructor: Rabbit}

alert(rabbit.constructor == Rabbit); // true (свойство получено из прототипа)
--------------
Мы можем использовать свойство constructor существующего объекта для создания нового.

Пример:

function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit("White Rabbit");

let rabbit2 = new rabbit.constructor("Black Rabbit");
--------------


_______________________________________________Встроенные прототипы______________________________________________________________
https://learn.javascript.ru/native-prototypes

Цепочки прототипов.------
--------------
new Object().constructor == Object; // true
--------------
let obj = {};
console.log(obj.__proto__ == Object.prototype && Object.prototype.__proto__ == null ); // true

--------------
let arr = [1, 2, 3];
arr.__proto__ == Array.prototype && Array.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null // true

--------------
function func(){};
console.log(func.__proto__ == Function.prototype && Function.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null );// true

--------------
let date = new Date();
  console.log(date.__proto__ == Date.prototype && Date.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )// true

--------------
let num = 100;
  console.log(num.__proto__ == Number.prototype && Number.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )// true

--------------
let str = "string";
  console.log(str.__proto__ == String.prototype && String.prototype.__proto__ == Object.prototype && Object.prototype.__proto__ == null )

--------------
Примитивы

Самое сложное происходит со строками, числами и булевыми значениями.
Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, 
то тогда будет создан временный объект-обёртка с использованием
встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.

Эти объекты создаются невидимо для нас, и большая часть движков оптимизирует этот процесс, 
но спецификация описывает это именно таким образом.
Методы этих объектов также находятся в прототипах, доступных как String.prototype, Number.prototype и Boolean.prototype.

Значения null и undefined не имеют объектов-обёрток
Специальные значения null и undefined стоят особняком. У них нет объектов-обёрток, так что методы и свойства им недоступны. Также у них нет 
соответствующих прототипов.
-------------
Изменение встроенных прототипов

Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() => f.apply(this, args), ms);
  }
};

// check it
function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // выведет 3 через 1 секунду.
--------------
Заимствование у прототипов
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

obj.join = Array.prototype.join;

alert( obj.join(',') ); // Hello,world!

__________________________________________Методы прототипов, объекты без свойства __proto_______________________________________________
https://learn.javascript.ru/prototype-methods

Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto,
и необязательными дескрипторами свойств descriptors.

let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: "I jump",
    writable: true,
    enumerable: true,
    conficurable: true
  }
});

console.log(rabbit.jumps) // "I jump"
------------
Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
------------
Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
------------
------------
Эти методы нужно использовать вместо __proto__.

Например:

let animal = {
  eats: true
};

// создаём новый объект с прототипом animal
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // получаем прототип объекта rabbit

Object.setPrototypeOf(rabbit, {}); // заменяем прототип объекта rabbit на {}
У Object.create есть необязательный второй аргумент: дескрипторы свойств.
------------
Мы также можем использовать Object.create для «продвинутого» клонирования объекта, более мощного, чем копирование свойств в цикле for..in:
// клон obj c тем же прототипом (с поверхностным копированием свойств)

let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));

Такой вызов создаёт точную копию объекта obj, включая все свойства: перечисляемые и неперечисляемые, геттеры/сеттеры для свойств – и всё 
это с правильным свойством [[Prototype]].
------------
Не меняйте [[Prototype]] существующих объектов, если важна скорость
Технически мы можем установить/получить [[Prototype]] в любое время. Но обычно мы устанавливаем прототип только раз во время создания объекта, 
а после не меняем: rabbit наследует от animal, и это не изменится.

И JavaScript движки хорошо оптимизированы для этого. Изменение прототипа «на лету» с помощью Object.setPrototypeOf или obj.__proto__= – очень медленная 
операция, которая ломает внутренние оптимизации для операций доступа к свойствам объекта. 
Так что лучше избегайте этого кроме тех случаев, когда вы знаете, 
что делаете, или же когда скорость JavaScript для вас не имеет никакого значения.
------------
"Простейший" объект
https://learn.javascript.ru/prototype-methods#very-plain

------------
Итого
Современные способы установки и прямого доступа к прототипу это:

Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), 
и необязательными дескрипторами свойств.
Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте. Как минимум потому,
что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, 
они непредсказуемы.

Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.

Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:

let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.

Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно использовать как «чистые словари», у них нет проблем
с использованием строки "__proto__" в качестве ключа.

Ещё методы:

Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных 
строковых ключей/значений/пар ключ-значение.
Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и 
унаследованные, можно воспользоваться циклом for..in.

_______________________________________________Классы базовый синтаксис______________________________________________________________
https://learn.javascript.ru/class
Базовый синтаксис для классов выглядит так:

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, 
геттеры и сеттеры записываются в MyClass.prototype.
---------------
Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
---------------
Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.
---------------
Class Expression (по аналогии с Function Expression):

let User = class {
  sayHi() {
    alert("Привет");
  }
};
Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:

// "Named Class Expression"
// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // имя MyClass видно только внутри класса
  }
};

new User().sayHi(); // работает, выводит определение MyClass

alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
---------------
Мы даже можем динамически создавать классы «по запросу»:

function makeClass(phrase) {
  // объявляем класс и возвращаем его
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// Создаём новый класс
let User = makeClass("Привет");

new User().sayHi(); // Привет
---------------
Геттеры/сеттеры, другие сокращения
Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Вот пример user.name, реализованного с использованием get/set:

class User {

  constructor(name) {
    // вызывает сеттер
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое.");
      return;
    }
    this._name = value;
  }

}

let user = new User("Иван");
alert(user.name); // Иван

user = new User(""); // Имя слишком короткое.
---------
При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:

Object.defineProperties(User.prototype, {
  name: {
    get() {
      return this._name
    },
    set(name) {
      // ...
    }
  }
});
---
Пример с вычисляемым свойством в скобках [...]:

class User {

  ['say' + 'Hi']() {
    alert("Привет");
  }

}

new User().sayHi();
---------------
Свойства классов
Старым браузерам может понадобиться полифил
Свойства классов добавлены в язык недавно.

В приведённом выше примере у класса User были только методы. Давайте добавим свойство:

class User {
  name = "Аноним";

  sayHi() {
    alert(`Привет, ${this.name}!`);
  }
}

new User().sayHi();
Свойство name не устанавливается в User.prototype. Вместо этого оно создаётся 
оператором new перед запуском конструктора, это именно свойство объекта.

__________________________________________________Наследование классов___________________________________________________________
Ниже Rabbit наследует от Animal:

class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} стоит.`);
  }
}

// Наследуем от Animal указывая "extends Animal"
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.hide(); // Белый кролик прячется!

Теперь код Rabbit стал короче, так как используется конструктор класса Animal по умолчанию и кролик 
может использовать метод run как и все животные.

Ключевое слово extends работает, используя прототипы. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. 
Так что если метод не найден в Rabbit.prototype, JavaScript берёт его из Animal.prototype.
---------------
После extends разрешены любые выражения
Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение.

Пример вызова функции, которая генерирует родительский класс:

function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}

class User extends f("Привет") {}

new User().sayHi(); // Привет
Здесь class User наследует от результата вызова f("Привет").

Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от
многих условий и затем наследовать их.
---------------
Переопределение методов
Давайте пойдём дальше и переопределим метод. Сейчас Rabbit наследует от Animal метод stop, который устанавливает this.speed = 0.

Если мы определим свой метод stop в классе Rabbit, то он будет использоваться взамен родительского:

У классов есть ключевое слово "super" для таких случаев.

super.method(...) вызывает родительский метод.
super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).
Пусть наш кролик автоматически прячется при остановке:

class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} бежит со скоростью ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} стоит.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется!`);
  }

  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(5); // Белый кролик бежит со скоростью 5.
rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!
Теперь у класса Rabbit есть метод stop, который вызывает родительский super.stop() в процессе выполнения.
И родительский конструктор где задается name;
---------------
У стрелочных функций нет super
Как упоминалось в главе Повторяем стрелочные функции, стрелочные функции не имеют super.

При обращении к super стрелочной функции он берётся из внешней функции:

class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
  }
}
В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается.
Если бы мы указали здесь «обычную» функцию, была бы ошибка:

// Unexpected super
setTimeout(function() { super.stop() }, 1000);
---------------
Переопределение конструктора
С конструкторами немного сложнее.

До сих пор у Rabbit не было своего конструктора.

Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:

class Rabbit extends Animal {
  // генерируется для классов-потомков, у которых нет своего конструктора
  constructor(...args) {
    super(...args);
  }
}
Как мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор.
---------------
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// теперь работает
let rabbit = new Rabbit("Белый кролик", 10);
alert(rabbit.name); // Белый кролик
alert(rabbit.earLength); // 10
---------------
[[HomeObject]]
Для решения этой проблемы в JavaScript было добавлено специальное внутреннее свойство для функций: [[HomeObject]].

Когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]] становится равно этому объекту.

Затем super использует его, чтобы получить прототип родителя и его методы.

Давайте посмотрим, как это работает – опять же, используя простые объекты:

let animal = {
  name: "Животное",
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} ест.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "Кролик",
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "Длинноух",
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// работает верно
longEar.eat();  // Длинноух ест.
Это работает как задумано благодаря [[HomeObject]]. Метод, такой как longEar.eat, знает свой [[HomeObject]] и получает
метод родителя из его прототипа. Вообще без использования this.
---------------
Методы, а не свойства-функции
Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов.
Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".

Для нас различий нет, но они есть для JavaScript.

В приведённом ниже примере используется синтаксис не метода, свойства-функции. Поэтому у него нет [[HomeObject]], и наследование не работает:

let animal = {
  eat: function() { // намеренно пишем так, а не eat() { ...
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // Ошибка вызова super (потому что нет [[HomeObject]])

_______________________________________________Статические свойства и методы______________________________________________________________
https://learn.javascript.ru/static-properties-methods

Итого
Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса.

Например, метод для сравнения двух статей Article.compare(article1, article2) или фабричный метод Article.createTodays().

В объявлении класса они помечаются ключевым словом static.

Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.

Синтаксис:

class MyClass {
  static property = ...;

  static method() {
    ...
  }
}
Технически, статическое объявление – это то же самое, что и присвоение классу:

MyClass.property = ...
MyClass.method = ...

Статические свойства и методы наследуются.
Для class B extends A прототип класса B указывает на A: B.[[Prototype]] = A. Таким образом, если поле не найдено в B, поиск продолжается в A.

_____________________________________________Приватные и защищённые методы и свойства________________________________________________________________
В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.

Внутренний и внешний интерфейсы
В объектно-ориентированном программировании свойства и методы разделены на 2 группы:

Внутренний интерфейс – методы и свойства, доступные из других методов класса, но не снаружи класса.
Внешний интерфейс – методы и свойства, доступные снаружи класса.
---------------
Защищённые свойства обычно начинаются с префикса _.

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне.
Большинство программистов следуют этому соглашению.

Так что наше свойство будет называться _waterAmount:

class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
Теперь доступ под контролем, поэтому указать воду ниже нуля не удалось.
---------------
Свойство только для чтения «power»
Давайте сделаем свойство power доступным только для чтения. Иногда нужно, чтобы свойство устанавливалось только при создании 
объекта и после этого никогда не изменялось.

Это как раз требуется для кофеварки: мощность никогда не меняется.

Для этого нам нужно создать только геттер, но не сеттер:

class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// создаём кофеварку
let coffeeMachine = new CoffeeMachine(100);

alert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W

coffeeMachine.power = 25; // Error (no setter)
---------------
Защищённые поля наследуются
Если мы унаследуем class MegaMachine extends CoffeeMachine, ничто не помешает нам обращаться к 
this._waterAmount или this._power из методов нового класса.

Таким образом защищённые методы, конечно же, наследуются. В отличие от приватных полей, в чём мы убедимся ниже.
---------------
Геттеры/сеттеры
Здесь мы использовали синтаксис геттеров/сеттеров.

Но в большинстве случаев использование функций get.../set... предпочтительнее:

class CoffeeMachine {
  _waterAmount = 0;

  setWaterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  getWaterAmount() {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);
Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны).
Итак, на будущее, если нам надо что-то отрефакторить, функции – более безопасный выбор.

С другой стороны, синтаксис get/set короче, решать вам.
-------------------------
Приватное свойство «#waterLimit»
Новая возможность
Эта возможность была добавлена в язык недавно. В движках JavaScript пока не поддерживается или поддерживается частично, нужен полифил.
Есть новшество в языке JavaScript, которое почти добавлено в стандарт: оно добавляет поддержку приватных свойств и методов.

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
--
class coffeMashin {
  #limitWater = 200;
  
  set limitWater(value){
    if(value < 0) throw new Error("Very small water count");
    if(value > this.#limitWater ) throw new Error('Very big water count');
    this.#limitWater = value;
  }
  
  get limitWater() {
      return this.#limitWater;
    }
}

let coff = new coffeMashin();
coff.limitWater = 55
console.log(coff.limitWater)
---------------
В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. Это хорошо.

Но если мы унаследуем от CoffeeMachine, то мы не получим прямого доступа к #waterAmount. 
Мы будем вынуждены полагаться на геттер/сеттер waterAmount:

class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine
  }
}
Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем CoffeeMachine, у нас может быть вполне 
законная причина для доступа к внутренним методам и свойствам. 
Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.
---------------
Важно:
Приватные поля особенные.

Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]:

class User {
  ...
  sayHi() {
    let fieldName = "name";
    alert(`Hello, ${this[fieldName]}`);
  }
}
С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.

_________________________________________________Расширение встроенных классов____________________________________________________________
От встроенных классов, таких как Array, Map и других, тоже можно наследовать.

// добавим один метод (можно более одного)
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false
Обратите внимание на интересный момент: встроенные методы, такие как filter, map и другие возвращают новые объекты 
унаследованного класса PowerArray. Их внутренняя реализация такова, что для этого они используют свойство объекта constructor.

В примере выше,

arr.constructor === PowerArray
Поэтому при вызове метода arr.filter() он внутри создаёт массив результатов, именно используя arr.constructor,
  а не обычный массив. Это замечательно, поскольку можно продолжать использовать методы PowerArray далее на результатах.

Более того, мы можем настроить это поведение.

При помощи специального статического геттера Symbol.species можно вернуть конструктор, который JavaScript
будет использовать в filter, map и других методах для создания новых объектов.

Если бы мы хотели, чтобы методы map, filter и т. д. возвращали обычные массивы, мы могли бы вернуть Array в Symbol.species, вот так:

class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  // встроенные методы массива будут использовать этот метод как конструктор
  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

// filter создаст новый массив, используя arr.constructor[Symbol.species] как конструктор
let filteredArr = arr.filter(item => item >= 10);

// filteredArr не является PowerArray, это Array
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
Как вы видите, теперь .filter возвращает Array. Расширенная функциональность не будет передаваться далее.

Аналогично работают другие коллекции
Другие коллекции, такие как Map, Set, работают аналогично. Они также используют Symbol.species.
-------------
Отсутствие статического наследования встроенных классов
У встроенных объектов есть собственные статические методы, например Object.keys, Array.isArray и т. д.

Как мы уже знаем, встроенные классы расширяют друг друга.

Обычно, когда один класс наследует другой, то наследуются и статические методы. Это было подробно разъяснено в главе Статические свойства и методы.

Но встроенные классы – исключение. Они не наследуют статические методы друг друга.

Например, и Array, и Date наследуют от Object, так что в их экземплярах доступны методы из Object.prototype. 
Но Array.[[Prototype]] не ссылается на Object, поэтому нет методов Array.keys() или Date.keys().
_______________________________________________Проверка класса: "instanceof"_____________________________________________________________
Оператор instanceof позволяет проверить, к какому классу принадлежит объект, с учётом цепочки наследования.
Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.

class Rabbit {}
let rabbit = new Rabbit();

// это объект класса Rabbit?
alert( rabbit instanceof Rabbit ); // true
Также это работает с функциями-конструкторами:

// вместо класса
function Rabbit() {}

alert( new Rabbit() instanceof Rabbit ); // true
…И для встроенных классов, таких как Array:

let arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
Пожалуйста, обратите внимание, что arr также принадлежит классу Object, потому что Array наследует от Object.
-------------
Обычно оператор instanceof просматривает для проверки цепочку прототипов. Но это поведение может быть изменено при помощи статического
метода Symbol.hasInstance.

Алгоритм работы obj instanceof Class работает примерно так:

Если имеется статический метод Symbol.hasInstance, тогда вызвать его: Class[Symbol.hasInstance](obj). Он должен вернуть либо true, 
либо false, и это конец. Это как раз и есть возможность ручной настройки instanceof.

Пример:

// проверка instanceof будет полагать,
// что всё со свойством canEat - животное Animal
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

let obj = { canEat: true };
alert(obj instanceof Animal); // true: вызван Animal[Symbol.hasInstance](obj)
Большая часть классов не имеет метода Symbol.hasInstance. В этом случае используется стандартная логика: проверяется, равен ли Class.prototype
одному из прототипов в прототипной цепочке obj.

Другими словами, сравнивается:

obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
// если какой-то из ответов true - возвратить true
// если дошли до конца цепочки - false
В примере выше rabbit.__proto__ === Rabbit.prototype, так что результат будет получен немедленно.
В случае с наследованием, совпадение будет на втором шаге:
-------------
Кстати, есть метод objA.isPrototypeOf(objB), который возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB.
Так что obj instanceof Class можно перефразировать как Class.prototype.isPrototypeOf(obj).
Забавно, но сам конструктор Class не участвует в процессе проверки! Важна только цепочка прототипов Class.prototype.
-------------
Object.prototype.toString возвращает тип

// скопируем метод toString в переменную для удобства
let objectToString = Object.prototype.toString;

// какой это тип?
let arr = [];

alert( objectToString.call(arr) ); // [object Array]
----
let s = Object.prototype.toString;

alert( s.call(123) ); // [object Number]
alert( s.call(null) ); // [object Null]
alert( s.call(alert) ); // [object Function]
-------------
Symbol.toStringTag
Поведение метода объектов toString можно настраивать, используя специальное свойство объекта Symbol.toStringTag.

Например:

let user = {
  [Symbol.toStringTag]: "User"
};

alert( {}.toString.call(user) ); // [object User]
Такое свойство есть у большей части объектов, специфичных для определённых окружений. Вот несколько примеров для браузера:
----
class PowerArray extends Number {
  static [Symbol.toStringTag] = "user";
}
console.log(Object.prototype.toString.call(PowerArray))//[object user]
----
// toStringTag для браузерного объекта и класса
alert( window[Symbol.toStringTag]); // window
alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest

alert( {}.toString.call(window) ); // [object Window]
alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]
__________________________________________________Примеси__________________________________________________________
https://learn.javascript.ru/mixins

 Примесь – это класс, методы которого предназначены для использования в других классах, причём без наследования от примеси.
 С примесями могут возникнуть конфликты, если они перезаписывают существующие методы класса. Стоит помнить об этом и быть 
 внимательнее при выборе имён для методов примеси, чтобы их избежать
 -------------------
 // примесь
let sayHiMixin = {
  sayHi() {
    alert(`Привет, ${this.name}`);
  },
  sayBye() {
    alert(`Пока, ${this.name}`);
  }
};

// использование:
class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// теперь User может сказать Привет
new User("Вася").sayHi(); // Привет, Вася!
Это не наследование, а просто копирование методов. Таким образом, класс User может наследовать от другого класса, но при этом также 
включать в себя примеси, «подмешивающие» другие методы
 -------------------
 Примеси могут наследовать друг друга.
 В примере ниже sayHiMixin наследует от sayMixin:

let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (или мы можем использовать Object.create для задания прототипа)

  sayHi() {
    // вызываем метод родителя
    super.say(`Привет, ${this.name}`); // (*)
  },
  sayBye() {
    super.say(`Пока, ${this.name}`); // (*)
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// копируем методы
Object.assign(User.prototype, sayHiMixin);

// теперь User может сказать Привет
new User("Вася").sayHi(); // Привет, Вася!
Обратим внимание, что при вызове родительского метода super.say() из sayHiMixin (строки, помеченные (*)) 
этот метод ищется в прототипе самой примеси, а не класса.

Вот диаграмма (см правую часть):

Это связано с тем, что методы sayHi и sayBye были изначально созданы в объекте sayHiMixin. Несмотря на то,
что они скопированы, их внутреннее свойство [[HomeObject]] ссылается на sayHiMixin, как показано на картинке выше.

Так как super ищет родительские методы в [[HomeObject]].[[Prototype]], это означает sayHiMixin.[[Prototype]], а не User.[[Prototype]].
 -------------------
 https://learn.javascript.ru/mixins#eventmixin
 let eventMixin = {
  /**
   * Подписаться на событие, использование:
   * menu.on('select', function(item) { ... }
   */
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  /**
   * Отменить подписку, использование:
   * menu.off('select', handler)
   */
  off(eventName, handler) {
    let handlers = this._eventHandlers && this._eventHandlers[eventName];
    if (!handlers) return;
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i] === handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  /**
   * Сгенерировать событие с указанным именем и данными
   * this.trigger('select', data1, data2);
   */
  trigger(eventName, ...args) {
    if (!this._eventHandlers || !this._eventHandlers[eventName]) {
      return; // обработчиков для этого события нет
    }

    // вызовем обработчики
    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
  }
};
 ---------
 Итак, у нас есть 3 метода:

.on(eventName, handler) – назначает функцию handler, чтобы обработать событие с заданным именем. Обработчики хранятся в свойстве _eventHandlers, 
представляющим собой объект, в котором имя события является ключом, а массив обработчиков – значением.

.off(eventName, handler) – убирает функцию из списка обработчиков.

.trigger(eventName, ...args) – генерирует событие: все назначенные обработчики из _eventHandlers[eventName] вызываются, и ...args передаются 
им в качестве аргументов.

Использование:

// Создадим класс
class Menu {
  choose(value) {
    this.trigger("select", value);
  }
}
// Добавим примесь с методами для событий
Object.assign(Menu.prototype, eventMixin);

let menu = new Menu();

// Добавить обработчик, который будет вызван при событии "select":
menu.on("select", value => alert(`Выбранное значение: ${value}`));

// Генерирует событие => обработчик выше запускается и выводит:
menu.choose("123"); // Выбранное значение: 123

Теперь если у нас есть код, заинтересованный в событии "select", то он может слушать его с помощью menu.on(...).

А eventMixin позволяет легко добавить такое поведение в любой класс без вмешательства в цепочку наследования.

_______________________________________________Обработка ошибок __try__catch_____________________________________________________________
try {
  // исполняем код
} catch(err) {
  // если случилась ошибка, прыгаем сюда
  // err - это объект ошибки
} finally {
  // выполняется всегда после try/catch
}
--------------
Обычно скрипт в случае ошибки «падает» (сразу же останавливается), с выводом ошибки в консоль.
Но есть синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное.
Синтаксис «try…catch»
Конструкция try..catch состоит из двух основных блоков: try, и затем catch:

Пример с ошибками: выведет (1) и (3):

try {

  alert('Начало блока try');  // (1) <--
  lalala; // ошибка, переменная не определена!
  alert('Конец блока try (никогда не выполнится)');  // (2)

} catch(err) {

  alert(`Возникла ошибка!`); // (3) <--

}

Работает она так:

1.Сначала выполняется код внутри блока try {...}.
2.Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
3.Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). 
Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
-------------
try..catch работает только для ошибок, возникающих во время выполнения кода

try {
  {{{{{{{{{{{{
} catch(e) {
  alert("Движок не может понять этот код, он некорректен");
}

Таким образом, try..catch может обрабатывать только ошибки, которые возникают в корректном коде.
Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».
---------------
try..catch работает синхронно
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:

try {
  setTimeout(function() {
    noSuchVariable; // скрипт упадёт тут
  }, 1000);
} catch (e) {
  alert( "не сработает" );
}
Это потому, что функция выполняется позже, когда движок уже покинул конструкцию try..catch.
-----
Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:

setTimeout(function() {
  try {
    noSuchVariable; // try..catch обрабатывает ошибку!
  } catch {
    alert( "ошибка поймана!" );
  }
}, 1000);
---------------
Объект ошибки
Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch:

try {
  lalala; // ошибка, переменная не определена!
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)

  // Можем также просто вывести ошибку целиком
  // Ошибка приводится к строке вида "name: message"
  alert(err); // ReferenceError: lalala is not defined
}
-------------
Если json некорректен, JSON.parse генерирует ошибку, то есть скрипт «падает».

let json = "{ некорректный JSON }";

try {

  let user = JSON.parse(json); // <-- тут возникает ошибка...
  alert( user.name ); // не сработает

} catch (e) {
  // ...выполнение прыгает сюда
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
  alert( e.name );
  alert( e.message );
}
-------------
Генерация собственных ошибок
Что если json синтаксически корректен, но не содержит необходимого свойства name?

В JavaScript есть множество встроенных конструкторов для стандартных ошибок: 
Error, SyntaxError, ReferenceError, TypeError и другие. Можно использовать и их для создания объектов ошибки.

let error = new Error(message);
let error = new SyntaxError(message);
let error = new ReferenceError(message);
---
let error = new Error(" Ого, ошибка! o_O");

alert(error.name); // Error
alert(error.message); //  Ого, ошибка! o_O
---
Оператор throw генерирует ошибку.

let json = '{ "age": 30 }'; // данные неполны

try {
  let user = JSON.parse(json); // <-- выполнится без ошибок
  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени"); // (*)
  }
  alert( user.name );
  
} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
}
---
Проброс исключения (ошибки)
https://learn.javascript.ru/try-catch#probros-isklyucheniya
-------------
try…catch…finally
Подождите, это ещё не всё.

Конструкция try..catch может содержать ещё одну секцию: finally.

Если секция есть, то она выполняется в любом случае:

после try, если не было ошибок,
после catch, если ошибки были.
Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

try {
   ... пробуем выполнить код...
} catch(e) {
   ... обрабатываем ошибки ...
} finally {
   ... выполняем всегда ...
}
---
Конструкция try..finally без секции catch также полезна. 
Мы применяем её, когда не хотим здесь обрабатывать ошибки (пусть выпадут), но хотим быть уверены, что начатые процессы завершились.
---------------
Глобальный catch
https://learn.javascript.ru/try-catch#globalnyy-catch

window.onerror = function(message, url, line, col, error) {
  // ...
};

________________________________________Пользовательские ошибки, расширение Error_____________________________________________________
https://learn.javascript.ru/custom-errors
----------------------
class MyError extends Error {
  constructor(message) {
    super(message)
    this.name = this.constructor.name;
  }
}
    
class ValidationError extends MyError {};

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("NO property " + property);
    this.property = property;
  }
}

function readUser(json) {
  let user = JSON.parse(json);
  if(!user.name) throw new PropertyRequiredError("name");
  if(!user.age) throw new PropertyRequiredError("age");
  return user;
}

try{
  readUser('{"name": "JON", "ag": 33}');
}
catch(err) {
  if(err instanceof MyError) console.log(`${err.name} + ${err.message}`)
  else if(err instanceof SyntaxError) console.log(err.toString())
  else throw err
}
finally {
  console.log("end")
}
----------------------
Обёртывание исключений
https://learn.javascript.ru/custom-errors#obyortyvanie-isklyucheniy

Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» 
исключение вместо разных низкоуровневых. 
Иногда низкоуровневые исключения становятся свойствами этого объекта, как err.cause в примерах выше, но это не обязательно.
---------------------
_____________________________________________________Введение: колбэки_______________________________________________________
Подход, который мы использовали в loadScript, также распространён и называется «колбэк с первым аргументом-ошибкой» («error-first callback»).

1.Первый аргумент функции callback зарезервирован для ошибки. В этом случае вызов выглядит вот так: callback(err).
2.Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: callback(null, result1, result2…).
Одна и та же функция callback используется и для информирования об ошибке, и для передачи результатов.

function loadScript(src, callback){
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error("Err my"), script)
  document.head.append(script)
}

function f(err, script){
  if(err) console.log(err.message)
  else console.log("Great is loaded script " + script.src)
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.j', f )
-----------------
_________________________________________________Промисы___________________________________________________________
Promise – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. 
«Создающий» код может выполняться сколько потребуется, а «Потребляющий» код будет ждать результат 
(несмотря на асинхронность движок не пойдет дальше по коду, а будет ждать ответа промиса).
----
let promise = new Promise(function(resolve, reject) {
  
  // функция-исполнитель (executor)
  // запускается автоматически
  
  if(true) resolve("done")
  else reject(new Error("Err"))
  
})
.then(value => console.log(value), err => console.log(err.message)) //"done" - обрабатывает первой функцией resolve а второй reject.
или...
.then(value => console.log(value)) - Можно писать только одну первую если обрабатываем только resolve
-----
.catch(err => console.log(err.message) - Обрабатывает только ошибку (reject(err))

Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). 
Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:
-----
.finally(() => alert("Промис завершён")) - Вызов .finally(f) f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
.then(result => alert(result)); // <-- .then обработает результат
finally не предназначен для обработки результата промиса. Так что он просто пропускает его через себя дальше к последующим обработчикам.
----------------
Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. 
Она должна содержать «создающий» код, который когда-нибудь создаст результат. 
В виде...
resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки.
-----
Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.
У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

state  
(«состояние») — вначале "pending" («ожидание»), 
далее...
при вызове resolve меняется на "fulfilled" («выполнено успешно») 
при вызове reject меняется на "rejected" («выполнено с ошибкой») 

result 
(«результат») — вначале undefined
далее...    
при вызове resolve(value) изменяется на value
при вызове reject(error) изменится на error

Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа.
-------------
Может быть что-то одно: либо результат, либо ошибка

let promise = new Promise(function(resolve, reject) {
  resolve("done");

  reject(new Error("…")); // игнорируется
  setTimeout(() => resolve("…")); // игнорируется
});
--------------
loadScript на промисах (loadScript on promises)

function loadScript(src){
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error("Err my"))
    document.head.append(script)
  })
}

let promise = loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js' )

promise.then(
  value => console.log(value.src),
  err => console.log(err.message)
);

promise.then(value => console.log('one more handler'))
--------------
_____________________________________________Цепочка промисов_______________________________________________
https://learn.javascript.ru/promise-chaining
---------
Если обработчик в .then (или в catch/finally, без разницы) возвращает промис, последующие элементы цепочки ждут,  
пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.

Если обработчик возвращает не промис то значение передается следующему обработчики сразу. setTimeout будет проигнорирован
(движок пойдет дальше по коду) если он небудет помещен в "new Promise(resolve => setTimeout(() => resolve('defer'), 1000))"
----
new Promise(resolve => {
  setTimeout(() => resolve('one'), 1000)
})
.then(value => {

  console.log(value + ' Дождался завершения промиса') //one...
  return 'two';
  
})
.then(value => {

  console.log(value + ' Выполнился сразу, т.к ненадо ждать результат промиса'); //two...
  return new Promise(r => setTimeout(() => r('defer'), 1000))
  
})
.then(value => console.log(value + ' Дождался завершения промиса')) //defer...
-------------------
Thenable
Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, 
такие объекты называют «thenable», и этот объект будет обработан как промис.

Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут 
иметь свои наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод .then.

Вот пример такого объекта:

class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // будет успешно выполнено с аргументом this.num*2 через 1 секунду
    setTimeout(() => resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve => resolve(1))
  .then(result => {
    return new Thenable(result); // (*)
  })
  .then(alert); // показывает 2 через 1000мс
  
JavaScript проверяет объект, возвращаемый из обработчика .then в строке (*): если у него имеется метод then, 
который можно вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции resolve и reject,
вызов одной из которых потом ожидается. В примере выше происходит вызов resolve(2) через 1 секунду (**). 
Затем результат передаётся дальше по цепочке.

Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от Promise.
----------------
Метод fetch
Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.

let promise = fetch(url);

Этот код запрашивает по сети url и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект response после того,
как удалённый сервер присылает заголовки ответа, но до того, как весь ответ сервера полностью загружен.

Чтобы прочитать полный ответ, надо вызвать метод response.text(): он тоже возвращает промис, который выполняется,
когда данные полностью загружены с удалённого сервера, и возвращает эти данные.

fetch('/article/promise-chaining/user.json') - когда удалённый сервер отвечает, промис возвращает объект response
  .then(function(response) {
    // response.text() возвращает новый промис,
    // который выполняется и возвращает полный ответ сервера,
    // когда он загрузится
    return response.text();
  })
  .then(function(text) {
    // ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
  });
  ---
  // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
  
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя
  --------------
Разница в том, что если ошибка произойдёт в f1, то она будет обработана в .catch в этом примере:

promise
  .then(f1)
  .catch(f2);

…но не в этом:

promise
  .then(f1, f2);
  
Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после f1.

Другими словами, .then передаёт результат или ошибку следующему блоку .then/catch. 
Так как в первом примере в цепочке далее имеется блок catch, а во втором – нет, 
то ошибка в нём останется необработанной.
_________________________________________________Промисы: обработка ошибок______Промисы ошибки_____________________________________________________
Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит 
в ближайший обработчик ошибок. На практике это очень удобно.

Например, в представленном ниже примере для fetch указана неправильная ссылка (сайт не существует), и .catch перехватывает ошибку:

fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
-------------
Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. 
Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки:

fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));
  
Если все в порядке, то такой .catch вообще не выполнится. Но если любой из промисов будет отклонён 
(проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.
-------------
Неявный try…catch
Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, 
то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:

new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(alert); // Error: Ошибка!
…Работает так же, как и этот:

new Promise((resolve, reject) => {
  reject(new Error("Ошибка!"));
}).catch(alert); // Error: Ошибка!
"Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (throw) из обработчика (.then),
то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:

new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  throw new Error("Ошибка!"); // генерируем ошибку
}).catch(alert); // Error: Ошибка!
Это происходит для всех ошибок, не только для тех, которые вызваны оператором throw. Например, программная ошибка:

new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  blabla(); // нет такой функции
}).catch(alert); // ReferenceError: blabla is not defined
Финальный .catch перехватывает как промисы, в которых вызван reject, так и случайные ошибки в обработчиках.
-------------
Пробрасывание ошибок
Как мы уже заметили, .catch ведёт себя как try..catch. Мы можем иметь столько обработчиков .then, сколько мы хотим, 
и затем использовать один .catch в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном try..catch мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок.
А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then.

В примере ниже .catch успешно обрабатывает ошибку:

// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Управление перейдёт в следующий then"));
Здесь блок .catch завершается нормально. Поэтому вызывается следующий успешный обработчик .then.

В примере ниже мы видим другую ситуацию с блоком .catch. Обработчик (*) перехватывает ошибку и не может обработать её 
(например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:

// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

    throw error; // пробрасывает эту или другую ошибку в следующий catch
  }

}).then(function() {
  /* не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
Управление переходит от первого блока .catch (*) к следующему (**), вниз по цепочке.
-------------
Необработанные ошибки
https://learn.javascript.ru/promise-error-handling#neobrabotannye-oshibki
https://learn.javascript.ru/microtask-queue

window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
-------------
Не выполнится:

new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);

Как было сказано в главе, здесь присутствует "скрытый try..catch" вокруг кода функции. Поэтому обрабатываются все синхронные ошибки.
В данном примере ошибка генерируется не по ходу выполнения кода, а позже. Поэтому промис не может обработать её.
---
Выполнится 

new Promise(function(resolve, reject) {
  setTimeout(() => {
    reject(new Error("Whoops!"))
  }, 1000);
}).catch(err => console.log(err.message));
______________________________________________________________Promise API______________________________________________________________________

Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.
Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
Например, Promise.all, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив [1, 2, 3]:

Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива

Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. 
Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.
-------------
Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, 
и затем обернёт получившийся массив в Promise.all.

Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));

// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
-------------
Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.

Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Ошибка!

Здесь второй промис завершится с ошибкой через 2 секунды. Это приведёт к немедленной ошибке в Promise.all, так что выполнится .catch:  
ошибка этого промиса становится ошибкой всего Promise.all. В случае ошибки, остальные результаты игнорируются
Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке.
Их результаты игнорируются.

Например, если сделано несколько вызовов fetch, как в примере выше, и один не прошёл, 
то остальные будут всё ещё выполняться, но Promise.all за ними уже не смотрит. 
Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

Promise.all ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». 
-------------
Promise.all(iterable) разрешает передавать не-промисы в iterable (перебираемом объекте)
Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом,
он передаётся в итоговый массив «как есть».

Например, здесь результат: [1, 2, 3]

Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2,
  3
]).then(alert); // 1, 2, 3
Таким образом, мы можем передавать уже готовые значения, которые не являются промисами, в Promise.all, иногда это бывает удобно.
-------------
Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет

{status:"fulfilled", value:результат} для успешных завершений,
{status:"rejected", reason:ошибка} для ошибок.

Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.

Используем для этого Promise.allSettled:

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
Массив results в строке (*) будет таким:

[
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'rejected', reason: ...объект ошибки...}
]
То есть, для каждого промиса у нас есть его статус и значение/ошибка.
---
Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.
https://learn.javascript.ru/promise-api#polifil
-------------
Promise.race
Метод очень похож на Promise.all, но ждёт только первый промис, из которого берёт результат (или ошибку).

Синтаксис:

let promise = Promise.race(iterable);
Например, тут результат будет 1:

Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
'Быстрее всех выполнился первый промис, он и дал результат. После этого остальные промисы игнорируются.'
-------------
Promise.resolve/reject
Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await 
(мы рассмотрим его чуть позже) делает его, в общем-то, не нужным.

Мы рассмотрим их здесь для полноты картины, а также для тех, кто по каким-то причинам не может использовать async/await.

Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
То же самое, что:

let promise = new Promise(resolve => resolve(value));
Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.

Например, функция loadCached ниже загружает URL и запоминает (кеширует) его содержимое. 
При будущих вызовах с тем же URL он тут же читает предыдущее содержимое из кеша, 
но использует Promise.resolve, чтобы сделать из него промис, для того, чтобы возвращаемое значение всегда было промисом:

let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
    return Promise.resolve(cache.get(url)); // (*)
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
Мы можем писать loadCached(url).then(…), потому что функция loadCached всегда возвращает промис. 
Мы всегда можем использовать .then после loadCached. Это и есть цель использования Promise.resolve в строке (*).
---
Promise.reject
Promise.reject(error) создаёт промис, завершённый с ошибкой error.
То же самое, что:

let promise = new Promise((resolve, reject) => reject(error));
На практике этот метод почти никогда не используется.

_______________________________________________________________Промисификация_____________________________________________________________________
https://learn.javascript.ru/promisify
______________________________________________________________Микрозадачи______________________________________________________________________
Обработчики промисов .then/.catch/.finally всегда асинхронны.
Даже когда промис сразу же выполнен, код в строках ниже .then/.catch/.finally будет запущен до этих обработчиков.
--
let promise = Promise.resolve();
promise.then(() => alert("промис выполнен"));                  -

alert("код выполнен"); // этот alert показывается первым       + 
--
Если вы запустите его, сначала вы увидите код выполнен, а потом промис выполнен.
Rогда промис выполнен, его обработчики .then/catch/finally попадают в очередь. 
Они пока не выполняются. Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Вот почему сообщение «код выполнен» в примере выше будет показано первым.
-------------
Обработчики промисов всегда проходят через эту внутреннюю очередь.
Если есть цепочка с несколькими .then/catch/finally, то каждый из них выполняется асинхронно.
То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.
Но что если порядок имеет значение для нас? Как мы можем вывести код выполнен после промис выполнен?

Легко, используя .then:

Promise.resolve()
  .then(() => alert("промис выполнен!"))
  .then(() => alert("код выполнен"));
Теперь порядок стал таким, как было задумано.
-------------
Необработанные ошибки
https://learn.javascript.ru/microtask-queue#neobrabotannye-oshibki

______________________________________________________________Async await______________________________________________________________________
Асинхронные функции
Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.
--
async function f() {
  return 1;
}

У слова async один простой смысл: эта функция всегда возвращает промис. 
Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:

async function f() {
  return 1;
}
f().then(alert); // 1

Можно и явно вернуть промис, результат будет одинаковым:

async function f() {
  return Promise.resolve(1);
}
f().then(alert); // 1
--
Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.
------------------
Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. 
После чего оно вернёт его результат, и выполнение кода продолжится.
await нельзя использовать в обычных функциях и на верхнем уровне вложенности. Можно только в нутри функции с async;

В этом примере промис успешно выполнится через 1 секунду:
--
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
--
В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. 
Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, 
и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. 
Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.
-------------------
await работает с «thenable»–объектами
Как и promise.then, await позволяет работать с промис–совместимыми объектами. Идея в том, что если у объекта можно вызвать метод then, 
этого достаточно, чтобы использовать его с await.

В примере ниже, экземпляры класса Thenable будут работать вместе с await:
---
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve);
    // выполнить resolve со значением this.num * 2 через 1000мс
    setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
};

async function f() {
  // код будет ждать 1 секунду,
  // после чего значение result станет равным 2
  let result = await new Thenable(1);
  alert(result);
}

f();
---
Когда await получает объект с .then, не являющийся промисом, JavaScript автоматически запускает этот метод, 
передавая ему аргументы – встроенные функции resolve и reject. Затем await приостановит дальнейшее выполнение кода, 
пока любая из этих функций не будет вызвана (в примере это строка (*)). 
После чего выполнение кода продолжится с результатом resolve или reject соответственно.
------------------
Асинхронные методы классов
Для объявления асинхронного метода достаточно написать async перед именем:
--
class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1
--
Как и в случае с асинхронными функциями, такой метод гарантированно возвращает промис, и в его теле можно использовать await.
---------------------
Обработка ошибок
Когда промис завершается успешно, await promise возвращает результат. Когда завершается с ошибкой – будет выброшено исключение. 
Как если бы на этом месте находилось выражение throw.
--
Такой код:

async function f() {
  await Promise.reject(new Error("Упс!"));
}

Делает то же самое, что и такой:

async function f() {
  throw new Error("Упс!");
}
--
Но есть отличие: на практике промис может завершиться с ошибкой не сразу, а через некоторое время.
В этом случае будет задержка, а затем await выбросит исключение.

Такие ошибки можно ловить, используя try..catch, как с обычным throw:
--
async function f() {

  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();
--
В случае ошибки выполнение try прерывается и управление прыгает в начало блока catch. Блоком try можно обернуть несколько строк:

async function f() {

  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // перехватит любую ошибку в блоке try: и в fetch, и в response.json
    alert(err);
  }
}

f();
--
Если у нас нет try..catch, асинхронная функция будет возвращать завершившийся с ошибкой промис (в состоянии rejected). 
В этом случае мы можем использовать метод .catch промиса, чтобы обработать ошибку:
--
async function f() {
  let response = await fetch('http://no-such-url');
}

// f() вернёт промис в состоянии rejected
f().catch(alert); // TypeError: failed to fetch // (*)
--
Если забыть добавить .catch, то будет сгенерирована ошибка «Uncaught promise error» и информация об этом будет выведена в консоль. 
Такие ошибки можно поймать глобальным обработчиком, о чём подробно написано в разделе Промисы: обработка ошибок.
----------
async/await отлично работает с Promise.all
Когда необходимо подождать несколько промисов одновременно, можно обернуть их в Promise.all, и затем await:
--
// await будет ждать массив с результатами выполнения всех промисов
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);
--
В случае ошибки она будет передаваться как обычно: от завершившегося с ошибкой промиса к Promise.all. 
А после будет сгенерировано исключение, которое можно отловить, обернув выражение в try..catch.
-----------------
Вызовanm async–функцию из "обычной"

async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));          - __дождаться__

  return 10;
}

function f() {
  // покажет 10 через 1 секунду
  wait().then(result => alert(result));
}

f();

Здесь нужно думать о вызове функции async, как о промисе. И просто воспользоваться .then:

__________________________________________________________________Генераторы__________________________________________________________________
____________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________
____________________________________________Браузерное окружение, спецификации______________________________________________________

Корневой объект window, который выступает в 2 ролях:

Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

alert(window.innerHeight); // внутренняя высота окна браузера

____________________________________________DOM (Document Object Model)____________________________________________________
DOM (Document Object Model)
Document Object Model, сокращённо DOM – объектная модель документа, 
которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
-------------
Таблицы всегда содержат <tbody>

Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть <tbody>, 
но в HTML их можно написать (официально) без него.
В этом случае браузер добавляет <tbody> в DOM самостоятельно.
-------------
Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:

document – «входная точка» в DOM.
узлы-элементы – HTML-теги, основные строительные блоки.
текстовые узлы – содержат текст.
комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
-------------
Из консоли в инструменте разработчика в браузере. Можно выбрать элемент. И писать js для него вот так:
 $0.style.background = 'red'
__________________________________________________Навигация по DOM-элементам__________________________________________________

Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.

Самые верхние элементы дерева доступны как свойства объекта document:
-------------
<html> = document.documentElement
Самый верхний узел документа: document.documentElement. В DOM он соответствует тегу <html>.
-------------
<head> = document.head
Тег <head> доступен как document.head.
-------------
<body> = document.body
Другой часто используемый DOM-узел – узел тега <body>: document.body.
-------------
Если скрипт находится в <head>, document.body в нём недоступен, потому что браузер его ещё не прочитал. body == null
=============

childNodes - это коллекция которая содержит список всех детей, 
включая текстовые узлы, для выбранного элемента head,body,html итд
--

for (let i = 0; i < document.body.childNodes.length; i++) {
      console.log( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
--

Для перебора коллекции мы можем использовать for..of:

for (let node of document.body.childNodes) {
  alert(node); // покажет все узлы из коллекции
}
--

Из childNodes можно создать массив

console.log( Array.from(document.body.childNodes).filter ); // сделали массив чтобы применять методы массивов
-------------

firstChild - быстрый доступ к первому дочернему элементу.  == elem.childNodes[0]                          === elem.firstChild
lastChild -быстрый доступ к последнему дочернему элементу. == elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
-------------

nextSibling - cледующий узел того же родителя (следующий сосед)  == document.head.nextSibling  // HTMLBodyElement
previousSibling - предыдущий узел того же родителя (следующий сосед) == document.body.previousSibling ); // HTMLHeadElement
-------------

parentNode - родитель узла => document.body.parentNode // <html>
-------------

________________________________________________Навигация только по элементам____________________________________________________

Навигационные свойства, описанные выше, относятся ко всем узлам в документе. 
В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

Но для большинства задач текстовые узлы и узлы-комментарии нам не нужны. 
Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.
-------------
Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:

children – коллекция детей, которые являются элементами.
firstElementChild, lastElementChild – первый и последний дочерний элемент.
previousElementSibling, nextElementSibling – соседи-элементы.
parentElement – родитель-элемент.
-------------
while(elem = elem.parentElement) { // идти наверх до <html>
  alert( elem );
}
-------------
Теперь цикл выводит только элементы:

for (let elem of document.body.children) {
  alert(elem); // DIV, UL, DIV, SCRIPT
}
-------------
Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:

table.rows – коллекция строк <tr> таблицы.
table.caption/tHead/tFoot – ссылки на элементы таблицы <caption>, <thead>, <tfoot>.
table.tBodies – коллекция элементов таблицы <tbody> (по спецификации их может быть больше одного).
<thead>, <tfoot>, <tbody> предоставляют свойство rows:

tbody.rows – коллекция строк <tr> секции.
<tr>:

tr.cells – коллекция <td> и <th> ячеек, находящихся внутри строки <tr>.
tr.sectionRowIndex – номер строки <tr> в текущей секции <thead>/<tbody>/<tfoot>.
tr.rowIndex – номер строки <tr> в таблице (включая все строки таблицы).
<td> and <th>:

td.cellIndex – номер ячейки в строке <tr>.
--

Пример использования:

<table id="table">
  <tr>
    <td>один</td><td>два</td>
  </tr>
  <tr>
    <td>три</td><td>четыре</td>
  </tr>
</table>


// выводит содержимое первой строки, второй ячейки
console.log( table.rows[0].cells[1].innerHTML ) // "два"
-------------

________________________________________________Поиск: getElement*, querySelector*______________________________________________
-------------
document.getElementById(id)

Если у элемента есть атрибут id, то мы можем получить его , где бы он ни находился.
Значение id должно быть уникальным. Только document.getElementById
Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу

let elem = document.getElementById('elem');

-------------
elem.querySelectorAll(css)

возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.
Пример поиска по таблице
--
let elements = document.querySelectorAll('tr:nth-child(1) > td:first-child')

for(let elem of elements) {
    console.log(elem.innerHTML)
}
--
Псевдоклассы тоже работают
Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. 
Например, document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности:
от внешнего к внутреннему) из текущих элементов под курсором мыши.
-------------
querySelector

Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору.
Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все элементы,
а потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. Это быстрее
-------------
matches

Предыдущие методы искали по DOM.
Метод elem.matches(css) ничего не ищет, а проверяет, 
удовлетворяет ли elem CSS-селектору, и возвращает true или false.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) 
и пытаемся выбрать те из них, которые нас интересуют.

Например:

<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
-------------
closest

Предки элемента – родитель, родитель родителя, его родитель и так далее. 
Вместе они образуют цепочку иерархии от элемента до вершины.

Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору.
 Сам элемент также включается в поиск.

Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. 
Если он соответствует селектору, поиск прекращается. 
Метод возвращает либо предка, либо null, если такой элемент не найден.

Например:

<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>
-------------
Можете встретить их в старом коде.
https://learn.javascript.ru/searching-elements-dom#getelementsby
--
elem.getElementsByTagName(tag) 
ищет элементы с данным тегом и возвращает их коллекцию. 
Передав "*" вместо тега, можно получить всех потомков.
--
elem.getElementsByClassName(className) 
возвращает элементы, которые имеют данный CSS-класс.
--
document.getElementsByName(name) 
возвращает элементы с заданным атрибутом name. Очень редко используется.
-------------

Метод			Ищет по...	Ищет внутри элемента?	Возвращает живую коллекцию?
querySelectorAll	CSS-selector		✔			-
querySelector		CSS-selector		✔			-
getElementById		id			-			-
getElementsByName	name			-			✔
getElementsByTagName	tag or '*'		✔			✔
getElementsByClassName	class			✔			✔
-------------
Пример навигации

// 1. Таблица с `id="age-table"`.
let table = document.getElementById('age-table')

// 2. Все label в этой таблице
table.getElementsByTagName('label')
// или
document.querySelectorAll('#age-table label')

// 3. Первый td в этой таблице
table.rows[0].cells[0]
// или
table.getElementsByTagName('td')[0]
// или
table.querySelector('td')

// 4. Форма с name="search"
// предполагаем, что есть только один элемент с таким name в документе
let form = document.getElementsByName('search')[0]
// или, именно форма:
document.querySelector('form[name="search"]')

// 5. Первый input в этой форме
form.getElementsByTagName('input')[0]
// или
form.querySelector('input')

// 6. Последний input в этой форме
let inputs = form.querySelectorAll('input') // найти все input
inputs[inputs.length-1] // взять последний

___________________________________________Свойства узлов: тип, тег и содержимое____________________________________________

Существуют следующие классы:

EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой, 
благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность: 
parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. 
Но есть определённые классы узлов, которые наследуют от него: Text – для текстовых узлов, 
Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.

Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling,
children и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, 
но также XML и SVG. Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:
HTMLInputElement – класс для тега <input>,
HTMLBodyElement – класс для тега <body>,
HTMLAnchorElement – класс для тега <a>,
…и т.д, каждому тегу соответствует свой класс, который предоставляет определённые свойства и методы.
---------------------

Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство constructor.
Оно ссылается на конструктор класса, и в свойстве constructor.name содержится его имя:

alert( document.body.constructor.name ); // HTMLBodyElement

…Или мы можем просто привести его к строке:

alert( document.body ); // [object HTMLBodyElement]
---------------------

tagName есть только у элементов Element. alert( document.body.nodeName ); // BODY

nodeName определено для любых узлов Node: alert( document.body.tagName ); // BODY
для элементов оно равно tagName.
для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
---------------------

innerHTML позволяет получить HTML-содержимое элемента в виде строки. Можем изменять его "=" или добавлять "+="

innerHTML+= делает следующее: Перезаписывает: Лучше не применять. почитать ссылку. Есть другой способ добавления
https://learn.javascript.ru/basic-dom-node-properties#budte-vnimatelny-innerhtml-osuschestvlyaet-perezapis

1.Старое содержимое удаляется.
2.На его место становится новое значение innerHTML (с добавленной строкой).
---------------------

outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
При замене заменяет тег эллемента.
---
<div>Привет, мир!</div>

  let div = document.querySelector('div');
  // заменяем div.outerHTML на <p>...</p>
  div.outerHTML = '<p>Новый элемент</p>'; // (*)

  // Ранее полученное одержимое div.outerHTML сохраняется!
  alert(div.outerHTML); // <div>Привет, мир!</div> (**)
---
Мы можем получить ссылки на новые элементы, обратившись к DOM.
---------------------
nodeValue и data похожи - для чтения содержимого текстового узла и комментариев
---------------------
textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.

 let name = prompt("Введите ваше имя?", "<b>Винни-пух!</b>");

  elem1.innerHTML = name;// Винни-пух! с применение тега <b>
  elem2.textContent = name;// <b>Винни-пух!</b>  вставиться как строка

textContent – один из способов от этого защититься от вставки в код лишнего HTML.
---------------------

Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.
Мы можем использовать его в HTML или назначать при помощи JavaScript, как в примере ниже:
---
<div>Оба тега DIV внизу невидимы</div>

<div hidden>С атрибутом "hidden"</div>

<div id="elem">С назначенным JavaScript свойством "hidden"</div>

<script>
  elem.hidden = true;
</script>
---
Технически, hidden работает так же, как style="display:none". Но его применение проще.
Мигающий элемент:

<div id="elem">Мигающий элемент</div>

<script>
  setInterval(() => elem.hidden = !elem.hidden, 1000); 
</script>

====
let elem = true
setInterval(() =>  console.log(elem = !elem), 1000)// false true false true false
====
---------------------
Другие свойства
У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

value – значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
href – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
id – значение атрибута «id» для всех элементов (HTMLElement).
…и многие другие…
Например:

<input type="text" id="elem" value="значение">

<script>
  alert(elem.type); // "text"
  alert(elem.id); // "elem"
  alert(elem.value); // значение
</script>

Большинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство, и мы можем получить к нему доступ.

Если мы хотим узнать полный список поддерживаемых свойств для данного класса, можно найти их в спецификации. 
Например, класс HTMLInputElement описывается здесь: https://html.spec.whatwg.org/#htmlinputelement.

Если же нам нужно быстро что-либо узнать или нас интересует специфика определённого браузера – мы всегда 
можем вывести элемент в консоль, используя console.dir(elem), и прочитать все свойства. 
Или исследовать «свойства DOM» во вкладке Elements браузерных инструментов разработчика.


___________________________________________________Атрибуты и свойства____________________________________________________

Атрибуты – это то, что написано в HTML.
Свойства – это то, что находится в DOM-объектах.
---
Методы для работы с атрибутами:

elem.hasAttribute(name) – проверить на наличие.
elem.getAttribute(name) – получить значение.
elem.setAttribute(name, value) – установить значение.
elem.removeAttribute(name) – удалить атрибут.
elem.attributes – это коллекция всех атрибутов.
---
В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда, 
когда DOM-свойства не подходят, когда нужны именно атрибуты, например:

Нужен нестандартный атрибут. Но если он начинается с data-, тогда нужно использовать dataset.
Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, 
например, свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.
--------------

Например, для такого тега <body id="page"> у DOM-объекта будет такое свойство body.id="page".
Но преобразование атрибута в свойство происходит не один-в-один!
--------------

DOM-свойства
Ранее мы уже видели встроенные DOM-свойства. Их много. Но технически нас никто не ограничивает, 
и если этого мало – мы можем добавить своё собственное свойство.

DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.
Например, создадим новое свойство для document.body:
--
document.body.myData = {
  name: 'Caesar',
  title: 'Imperator'
};

alert(document.body.myData.title); // Imperator

Мы можем добавить и метод:

document.body.sayTagName = function() {
  alert(this.tagName);
};

document.body.sayTagName(); // BODY (значением "this" в этом методе будет document.body)
---
Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам:

Element.prototype.sayHi = function() {
  alert(`Hello, I'm ${this.tagName}`);
};

document.documentElement.sayHi(); // Hello, I'm HTML
document.body.sayHi(); // Hello, I'm BODY

Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
Им можно присвоить любое значение.
Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).
---------------------

HTML-атрибуты
В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, 
он распознаёт стандартные атрибуты и создаёт DOM-свойства для них. Нестандартрые можно получить с помощью:
Все атрибуты доступны с помощью следующих методов:

elem.hasAttribute(name) – проверяет наличие атрибута.
elem.getAttribute(name) – получает значение атрибута.
elem.setAttribute(name, value) – устанавливает значение атрибута.
elem.removeAttribute(name) – удаляет атрибут.

Эти методы работают именно с тем, что написано в HTML.
---------------------
Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes: коллекция объектов, 
которая принадлежит ко встроенному классу Attr со свойствами name и value.
У HTML-атрибутов есть следующие особенности:

Их имена регистронезависимы (id то же самое, что и ID).
Их значения всегда являются строками.
--
<body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') ); // (1) 'Elephant', чтение

    elem.setAttribute('Test', 123); // (2), запись

    alert( elem.outerHTML ); // (3),   <div id="elem" about="Elephant" test="123"></div>


    for (let attr of elem.attributes) { // (4) весь список
      alert( `${attr.name} = ${attr.value}` );
    }
  </script>
</body>
---------------------

Синхронизация между атрибутами и свойствами
https://learn.javascript.ru/dom-attributes-and-properties#sinhronizatsiya-mezhdu-atributami-i-svoystvami
---------------------
DOM-свойства типизированы
DOM-свойства не всегда являются строками. Например, свойство input.checked (для чекбоксов) имеет логический тип:

<input id="input" type="checkbox" checked> checkbox

<script>
  alert(input.getAttribute('checked')); // значение атрибута: пустая строка
  alert(input.checked); // значение свойства: true
</script>
--
Есть и другие примеры. Атрибут style – строка, но свойство style является объектом:

<div id="div" style="color:red;font-size:120%">Hello</div>

<script>
  // строка
  alert(div.getAttribute('style')); // color:red;font-size:120%

  // объект
  alert(div.style); // [object CSSStyleDeclaration]
  alert(div.style.color); // red
</script>

Хотя большинство свойств, всё же, строки.

При этом некоторые из них, хоть и строки, могут отличаться от атрибутов. Например, DOM-свойство href всегда содержит 
полный URL, даже если атрибут содержит относительный URL или просто #hash

Если же нужно значение href или любого другого атрибута в точности, 
как оно записано в HTML, можно воспользоваться getAttribute.
---------------------

Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.

<body data-about="Elephants">
<script>
  alert(document.body.dataset.about); // Elephants
</script>
--
Атрибуты, состоящие из нескольких слов, к примеру data-order-state, 
становятся свойствами, записанными с помощью верблюжьей нотации: dataset.orderState.

<style>
 .order[data-order-state="canceled"] {
    color: red;
  }
</style>

<div id="order" class="order" data-order-state="new">A new order.</div>

<script>
  // чтение
  alert(order.dataset.orderState); // new

  // изменение
  order.dataset.orderState = "pending"; // (*)
  // или
  order.setAttribute('data-order-state', 'red')
</script>
______________________________________________________Изменение документа____________________________________________________
Создание элемента

DOM-узел можно создать двумя методами:

document.createElement(tag)
Создаёт новый элемент с заданным тегом:
--
let div = document.createElement('div');
document.createTextNode(text)
--
Создаёт новый текстовый узел с заданным текстом:
let textNode = document.createTextNode('А вот и я');
------------
Создание сообщения
В нашем случае сообщение – это div с классом alert и HTML в нём:

let div = document.createElement('div');
div.className = "alert";
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
------------
методы для различных вариантов вставки:

node.append(...nodes or strings) – добавляет узлы или строки в конец node,
node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
node.before(...nodes or strings) – вставляет узлы или строки до node,
node.after(...nodes or strings) – вставляет узлы или строки после node,
node.replaceWith(...nodes or strings) – заменяет node заданными узлами или строками.
--
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  ol.before('before'); // вставить строку "before" перед <ol>
  ol.after('after'); // вставить строку "after" после <ol>

  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst); // вставить liFirst в начало <ol>

  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast); // вставить liLast в конец <ol>
</script>

--результат--

before
prepend
0
1
2
append
after
--

Итоговый список будет таким:

before
<ol id="ol">
  <li>prepend</li>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>append</li>
</ol>
after
------------

Эти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов.
Например, здесь вставляется строка и элемент:

<div id="div"></div>
<script>
  div.before('<p>Привет</p>', document.createElement('hr'));
</script>

Строки вставляются безопасным способом, как делает это elem.textContent.
Поэтому эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.
------------
Если мы хотим вставить HTML именно «как html», со всеми тегами и прочим
insertAdjacentHTML /Text /Element

elem.insertAdjacentHTML(where, html)

where – это специальное слово, указывающее, куда по отношению к elem производить вставку. 
Значение должно быть одним из следующих:

"beforebegin" – вставить html непосредственно перед elem,
"afterbegin" – вставить html в начало elem,
"beforeend" – вставить html в конец elem,
"afterend" – вставить html непосредственно после elem.
--
Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».
--
<div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
  div.insertAdjacentHTML('afterend', '<p>Пока</p>');
</script>

…Приведёт к:

<p>Привет</p>
<div id="div"></div>
<p>Пока</p>
--
У метода есть два брата:

elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML,
elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem.

Они существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только insertAdjacentHTML
------------
Удаление узлов
Для удаления узла есть методы node.remove().

Например, сделаем так, чтобы наше сообщение удалялось через секунду:

<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

  document.body.append(div);
  setTimeout(() => div.remove(), 1000);
</script>
------------
Переместить элемент в другое место – нет необходимости удалять его со старого.
Все методы вставки автоматически удаляют узлы со старых мест.

Например, давайте поменяем местами элементы:

<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
  // нет необходимости вызывать метод remove
  second.after(first); // берёт #second и после него вставляет #first
</script>
------------
Клонирование узлов: cloneNode
Как вставить ещё одно подобное сообщение?

Мы могли бы создать функцию и поместить код туда. Альтернатива – клонировать 
существующий div и изменить текст внутри него (при необходимости).

Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами.
Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
Пример копирования сообщения:

<div class="alert" id="div">
  <strong>Всем привет!</strong> Вы прочитали важное сообщение.
</div>

<script>
  let div2 = div.cloneNode(true); // клонировать сообщение
  div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

  div.after(div2); // показать клонированный элемент после существующего div
</script>
--------------
DocumentFragment

DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.
Мы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он «исчезает», вместо него вставляется его содержимое.
Например, getListContent ниже генерирует фрагмент с элементами <li>, которые позже вставляются в <ul>:

<ul id="ul"></ul>

<script>
function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)
</script>

Обратите внимание, что на последней строке с (*) мы добавляем DocumentFragment, но он «исчезает», поэтому структура будет:

<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
---

DocumentFragment редко используется. Зачем добавлять элементы в специальный вид узла, 
если вместо этого мы можем вернуть массив узлов? Переписанный пример:

<ul id="ul"></ul>

<script>
function getListContent() {
  let result = [];

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }

  return result;
}

ul.append(...getListContent()); // append + оператор "..." = друзья!
</script>
----------------
Устаревшие методы вставки/удаления
https://learn.javascript.ru/modifying-document#ustarevshie-metody-vstavki-udaleniya

parentElem.appendChild(node)
Добавляет node в конец дочерних элементов parentElem.

parentElem.insertBefore(node, nextSibling)
Вставляет node перед nextSibling в parentElem.

parentElem.replaceChild(node, oldChild)
Заменяет oldChild на node среди дочерних элементов parentElem.

parentElem.removeChild(node)
Удаляет node из parentElem (предполагается, что он родитель node).
----------------
Несколько слов о «document.write»
https://learn.javascript.ru/modifying-document#neskolko-slov-o-document-write

Вызов document.write(html) записывает html на страницу «прямо здесь и сейчас».
Вызов document.write работает только во время загрузки страницы.
Если вызвать его позже, то существующее содержимое документа затрётся.
--
<p>Через одну секунду содержимое этой страницы будет заменено...</p>
<script>
  // document.write через 1 секунду
  // вызов происходит после того, как страница загрузится, поэтому метод затирает содержимое
  setTimeout(() => document.write('<b>...Этим.</b>'), 1000);
</script>
--------------------Задачи-----
let data = {
    "Рыбы": {
      "форель": {},
      "лосось": {}
    },

    "Деревья": {
      "Огромные": {
        "секвойя": {},
        "дуб": {}
      },
      "Цветковые": {
        "яблоня": {},
        "магнолия": {}
      }
    }
  };

function createTreeDom(obj) {

    if(!Object.keys(obj).length) {
        return
    }
    let ul = document.createElement('ul')

    for(let key in obj) {

        let li = document.createElement('li')
        li.innerHTML = key
        ul.append(li)
        let childUl = createTreeDom(obj[key])
        if(childUl) li.append(childUl)
    }

    container.append(ul)
    return ul
}

createTreeDom(data)

_____________________________________________________Стили и классы______________________________________________________

elem.className соответствует атрибуту "class".
Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами.

<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
--------------------

elem.classList – это специальный объект с методами для добавления/удаления одного класса.

<body class="main page">
  <script>
    // добавление класса
    document.body.classList.add('article');
    alert(document.body.className); // main page article
  </script>
</body>
---
Методы classList:

elem.classList.add/remove("class") – добавить/удалить класс.
elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
--
Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of:

<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
--------------------

elem.style – это объект, который соответствует тому, что написано в атрибуте "style". 
Установка стиля elem.style.width="100px" работает так же, как наличие в атрибуте style строки width:100px.

Для свойства из нескольких слов используется camelCase:

background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth

Например:

document.body.style.backgroundColor = prompt('background color?', 'green');

Свойства с префиксом
Стили с браузерным префиксом, например, -moz-border-radius, -webkit-border-radius 
преобразуются по тому же принципу: дефис означает заглавную букву.

Например:

button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
--------------------

Сброс стилей
Иногда нам нужно добавить свойство стиля, а потом, позже, убрать его.

elem.style.display = "none" - добавить свойство
elem.style.display = "" - удалить свойство

Если мы установим в style.display пустую строку, то браузер применит CSS-классы и 
встроенные стили, как если бы такого свойства style.display вообще не было.
--------------------

style.cssText - Для задания нескольких стилей в одной строке используется
--
<div id="div">Button</div>

<script>
  // можем даже устанавливать специальные флаги для стилей, например, "important"
  div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `;

  alert(div.style.cssText);
</script>

Это свойство удаляет все существующие стили: оно не добавляет, а заменяет их. 
То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...').
--------------------

Вычисленные стили: getComputedStyle

getComputedStyle(element, [pseudo]) - получить текущее значение свойств стилей

element -Элемент, значения для которого нужно получить

pseudo - Указывается, если нужен стиль псевдоэлемента, например ::before. getComputedStyle(elem, ['before'])

getComputedStyle требует полное свойство! Например: paddingLeft, marginTop, borderTopWidth.
Результат вызова – объект со стилями, похожий на elem.style, но с учётом всех CSS-классов.

<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  <script>
    let computedStyle = getComputedStyle(document.body);

    // сейчас мы можем прочитать отступ и цвет

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>

getComputedStyle требует полное свойство! Например: paddingLeft, marginTop, borderTopWidth.

--------------------

___________________________________________________Размеры и прокрутка элементов________________________________________________

https://learn.javascript.ru/size-and-scroll#scrollleft-scrolltop
--------------------
offsetParent – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
offsetLeft/offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent.
--------------------

offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки.
--------------------

clientLeft/clientTop – расстояние от верхнего левого внешнего угла до внутренного. 
Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. 
Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится 
не справа, а слева, то clientLeft включает в своё значение её ширину.
--------------------

clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
--------------------

scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, 
но учитывают прокрученную, невидимую область элемента.
--------------------

scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
--------------------

Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, 
изменение которых заставляет браузер прокручивать элемент.

________________________________________________Размеры и прокрутка окна_______________________________________________

documentElement.clientHeight/Width. - высота/ширина окна за вычетом полосы прокрутки
window.innerWidth - полная ширина окна
--------------------

documentElement.scrollWidth/scrollHeight - полный размер документа //(неправильный вариант из-за кросбраузерности)
Чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert('Полная высота документа с прокручиваемой частью: ' + scrollHeight);
--------------------

window.pageYOffset - Текущая прокрутка сверху
window.pageXOffset - Текущая прокрутка слева

Эти свойства доступны только для чтения.
--------------------

Эти методы одинаково работают для всех браузеров.

window.scrollBy(x,y) - прокручивает страницу относительно её текущего положения. 
Например, scrollBy(0,10) прокручивает страницу на 10px вниз.

window.scrollTo(pageX,pageY) - прокручивает страницу на абсолютные координаты (pageX,pageY). 
То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно 
левого верхнего угла документа. Это всё равно, что поставить scrollLeft/scrollTop. 
Для прокрутки в самое начало мы можем использовать scrollTo(0,0).
--------------------

elem.scrollIntoView(top) прокручивает страницу, чтобы elem оказался вверху. У него есть один аргумент:

если top=true (по умолчанию), то страница будет прокручена, чтобы elem появился в верхней части окна. 
Верхний край элемента совмещён с верхней частью окна.

если top=false, то страница будет прокручена, чтобы elem появился внизу. 
Нижний край элемента будет совмещён с нижним краем окна.
--------------------

Запретить прокрутку
https://learn.javascript.ru/size-and-scroll-window#zapretit-prokrutku

document.body.style.overflow = 'hidden'
document.body.style.overflow = ''

Первая кнопка останавливает прокрутку, вторая возобновляет её.
--------------------
___________________________________________________Координаты___________________________________________________
https://learn.javascript.ru/coordinates

Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:

1. Относительно окна браузера – как position:fixed
	отсчёт идёт от верхнего левого угла окна.
	мы будем обозначать эти координаты как clientX/clientY

2. Относительно документа – как position:absolute
	отсчёт идёт от верхнего левого угла документа.
	мы будем обозначать эти координаты как pageX/pageY.
--------------------

Координаты относительно окна: getBoundingClientRect
https://learn.javascript.ru/coordinates#koordinaty-otnositelno-okna-getboundingclientrect
--
elem.getBoundingClientRect() - возвращает координаты в контексте окна для минимального по размеру прямоугольника, 
который заключает в себе элемент elem, в виде объекта встроенного класса DOMRect.

Основные свойства объекта типа DOMRect:

x/y – X/Y-координаты начала прямоугольника относительно окна,

width/height – ширина/высота прямоугольника (могут быть отрицательными).
Дополнительные, «зависимые», свойства:

top/bottom – Y-координата верхней/нижней границы прямоугольника,
left/right – X-координата левой/правой границы прямоугольника.
--------------------

document.elementFromPoint(x, y) - 
возвращает самый глубоко вложенный элемент в окне, находящийся по координатам (x, y).
Например, код ниже выделяет с помощью стилей и выводит имя тега элемента, 
который сейчас в центре окна браузера:

let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);

Поскольку используются координаты в контексте окна, то элемент может быть разным, 
в зависимости от того, какая сейчас прокрутка.
Для координат за пределами окна метод elementFromPoint возвращает null
--------------------
Применение для fixed позиционирования
https://learn.javascript.ru/coordinates#primenenie-dlya-fixed-pozitsionirovaniya
--------------------
Координаты относительно документа
https://learn.javascript.ru/coordinates#getCoords

// получаем координаты элемента в контексте документа
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + pageYOffset,
    left: box.left + pageXOffset
  };
}
--------------------
--------------------
______________________________________________________________________________________________________
______________________________________________________________________________________________________
______________________________________________________________________________________________________
______________________________________________________________________________________________________
______________________________________________________________________________________________________

